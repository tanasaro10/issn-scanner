<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ISSN Scanner → Sheet</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; margin: 0; padding: 14px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 14px; margin-bottom: 14px; }
    video { width: 100%; border-radius: 12px; background: #000; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; background: #f6f6f6; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .log { font-family: ui-monospace, SFMono-Regular, Consolas, monospace; white-space: pre-wrap; }
    .ok { color: #0a7a0a; } .err { color: #b00020; }
    input[type=text] { padding: 8px; border-radius: 8px; border: 1px solid #ccc; width: 100%; }
    label { font-size: 14px; color: #444; }
    .muted { color:#666; font-size:12px; margin-top:6px; }
  </style>
</head>
<body>
  <h2>Scanează ISSN → Google Sheet</h2>

  <div class="card">
    <div class="row">
      <button id="startBtn">Start cameră</button>
      <button id="stopBtn" disabled>Stop cameră</button>
      <button id="toggleTorchBtn" disabled>Torch</button>
    </div>
    <div style="margin-top:10px">
      <video id="preview" playsinline muted></video>
    </div>
  </div>

  <div class="card">
    <div class="row">
      <div style="flex:1">
        <label>Endpoint Apps Script</label>
        <input id="webhook" type="text" placeholder="YOUR_APPS_SCRIPT_WEBAPP_URL" />
      </div>
      <div style="flex-basis:220px">
        <label>Token</label>
        <input id="token" type="text" placeholder="REPLACE_WITH_SECRET" />
      </div>
    </div>
    <div class="row" style="margin-top:10px">
      <div style="flex:1">
        <label>Device ID (opțional)</label>
        <input id="deviceId" type="text" placeholder="ex. phone01" />
      </div>
      <div>
        <button id="saveCfgBtn" title="Salvează în browser (localStorage)">Salvează</button>
        <button id="clearCfgBtn" title="Șterge din browser">Șterge</button>
      </div>
    </div>
    <div class="muted">Poți trece valorile direct în URL: <code>?YOUR_APPS_SCRIPT_WEBAPP_URL=&amp;REPLACE_WITH_SECRET=</code>. Vor fi salvate automat local.</div>
  </div>

  <div class="card">
    <div><strong>Ultima detecție</strong></div>
    <div id="last" class="log"></div>
  </div>

  <script>
    // ===== Utils UI =====
    function log(msg, cls='') {
      const last = document.getElementById('last');
      last.innerHTML = `<div class="${cls}">${msg}</div>` + last.innerHTML;
    }
    const secureOk = () => (window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost');

    // ===== Config din URL / localStorage =====
    const webhookEl = document.getElementById('webhook');
    const tokenEl   = document.getElementById('token');
    const deviceEl  = document.getElementById('deviceId');

    function loadConfig() {
      // 1) din localStorage
      const lsWebhook = localStorage.getItem('scanner_webhook') || '';
      const lsToken   = localStorage.getItem('scanner_token') || '';
      const lsDevice  = localStorage.getItem('scanner_device') || '';
      if (lsWebhook) webhookEl.value = lsWebhook;
      if (lsToken)   tokenEl.value   = lsToken;
      if (lsDevice)  deviceEl.value  = lsDevice;

      // 2) din query string (suprascrie localStorage dacă există)
      const q = new URLSearchParams(location.search);
      const qsWebhook = q.get('YOUR_APPS_SCRIPT_WEBAPP_URL') || q.get('webhook') || q.get('url');
      const qsToken   = q.get('REPLACE_WITH_SECRET') || q.get('token') || q.get('secret');
      if (qsWebhook) webhookEl.value = qsWebhook;
      if (qsToken)   tokenEl.value   = qsToken;

      // 3) auto-salvare dacă vin prin URL
      if (qsWebhook || qsToken) saveConfig(false /* no log */);
    }
    function saveConfig(showMsg=true) {
      localStorage.setItem('scanner_webhook', webhookEl.value.trim());
      localStorage.setItem('scanner_token',   tokenEl.value.trim());
      localStorage.setItem('scanner_device',  deviceEl.value.trim());
      if (showMsg) log('Config salvată local.', 'ok');
    }
    function clearConfig() {
      localStorage.removeItem('scanner_webhook');
      localStorage.removeItem('scanner_token');
      localStorage.removeItem('scanner_device');
      webhookEl.value = ''; tokenEl.value = ''; deviceEl.value = '';
      log('Config ștearsă din localStorage.', 'ok');
    }
    document.getElementById('saveCfgBtn').addEventListener('click', () => saveConfig(true));
    document.getElementById('clearCfgBtn').addEventListener('click', clearConfig);
    loadConfig();

    // ===== ISSN helpers =====
    function issnFromEan13(ean) {
      if (!/^\d{13}$/.test(ean) || !ean.startsWith('977')) return null;
      const issn7 = ean.substring(3, 10);
      const variant = ean.substring(10, 12);
      const weights = [8,7,6,5,4,3,2];
      let sum = 0; for (let i=0;i<7;i++) sum += (+issn7[i]) * weights[i];
      const r = sum % 11, cd = (11 - r) % 11, check = (cd === 10) ? 'X' : String(cd);
      return { issn: issn7.slice(0,4)+'-'+issn7.slice(4)+check, variantCode: variant };
    }
    async function lookupTitleByISSN(issn) {
      try {
        const r = await fetch(`https://api.crossref.org/journals/${encodeURIComponent(issn)}`, { headers:{Accept:'application/json'} });
        if (!r.ok) throw 0; const j = await r.json();
        return j?.message?.title || j?.message?.publisher || '—';
      } catch { return '—'; }
    }

    // ===== POST cu fallback anti-CORS =====
    async function postToSheet(webhook, token, payload) {
      // Încercare 1: JSON
      try {
        const r = await fetch(webhook, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ token, ...payload })
        });
        const j = await r.json().catch(()=> ({}));
        return { ok: !!j.ok, info: j.error || '' };
      } catch(e1) {
        // Încercare 2: x-www-form-urlencoded (evită preflight în multe cazuri)
        try {
          const form = new URLSearchParams();
          form.set('token', token);
          Object.entries(payload).forEach(([k,v]) => form.set(k, v ?? ''));
          const r2 = await fetch(webhook, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: form.toString()
          });
          const j2 = await r2.json().catch(()=> ({}));
          return { ok: !!j2.ok, info: j2.error || '' };
        } catch(e2) {
          return { ok:false, info: String(e2) };
        }
      }
    }

    // ===== Cameră / Torch (BarcodeDetector) =====
    const preview = document.getElementById('preview');
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const torchBtn = document.getElementById('toggleTorchBtn');

    let stream = null, detector = null, scanning = false;
    let lastEan = null, lastAt = 0;

    async function ensureBarcodeDetector() {
      if (!('BarcodeDetector' in window)) return false;
      try {
        const formats = await window.BarcodeDetector.getSupportedFormats();
        return formats.includes('ean_13') || formats.includes('ean13');
      } catch { return false; }
    }
    async function startCamera() {
      if (!secureOk()) { log('Pagina nu este pe HTTPS — accesul la cameră va fi blocat.', 'err'); return; }
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: 'environment' } },
          audio: false
        });
        preview.srcObject = stream; await preview.play();
        stopBtn.disabled = false;
        try {
          const track = stream.getVideoTracks?.()[0];
          const caps = track?.getCapabilities?.();
          if (caps && 'torch' in caps) torchBtn.disabled = false;
        } catch {}
      } catch(e) {
        if (e.name === 'NotAllowedError' || e.name === 'SecurityError') log('Acces la cameră blocat de permisiuni.', 'err');
        else if (e.name === 'NotFoundError') log('Nu există cameră disponibilă sau e ocupată.', 'err');
        else log('Eroare pornire cameră: ' + (e.message || e.name), 'err');
      }
    }
    function stopCamera() {
      try { stream?.getTracks?.().forEach(t=>t.stop()); } catch {}
      stream = null; preview.srcObject = null;
      scanning = false; stopBtn.disabled = true; torchBtn.disabled = true;
    }
    async function toggleTorch() {
      const track = stream?.getVideoTracks?.()[0];
      if (!track) return;
      try {
        const caps = track.getCapabilities?.(); if (!caps || !('torch' in caps)) return log('Torch nesuportat pe acest device.', 'err');
        const st = track.getSettings?.()||{};
        await track.applyConstraints({ advanced:[{ torch: !st.torch }] });
      } catch (e) { log('Nu pot controla lanterna: ' + e.message, 'err'); }
    }

    async function scanLoop() {
      if (!detector || !scanning) return;
      try {
        const barcodes = await detector.detect(preview);
        if (barcodes && barcodes.length) {
          for (const b of barcodes) {
            const raw = String(b.rawValue || '').trim();
            if (!raw) continue;
            const now = Date.now();
            if (raw === lastEan && (now - lastAt) < 2000) continue;
            lastEan = raw; lastAt = now;

            if (!/^\d{13}$/.test(raw)) { log(`Ignorat (nu e EAN-13): ${raw}`); continue; }

            let issn = null, title = '—', variantCode = '';
            if (raw.startsWith('977')) {
              const p = issnFromEan13(raw);
              if (p) { issn = p.issn; variantCode = p.variantCode; title = await lookupTitleByISSN(issn); }
            } else {
              log(`Detectat ISBN (${raw}). App-ul e pentru ISSN (977).`, 'err');
            }

            const webhook = webhookEl.value.trim(), token = tokenEl.value.trim();
            if (!webhook || !token) {
              log(`EAN: ${raw}\nISSN: ${issn || '—'}\nTitlu: ${title}\n(Configurează Webhook & Token)`, 'err');
              continue;
            }
            const resp = await postToSheet(webhook, token, {
              ean: raw, issn, title, variantCode, deviceId: deviceEl.value.trim() || ''
            });
            if (resp.ok) log(`✔ Salvat\nEAN: ${raw}\nISSN: ${issn||'—'}\nTitlu: ${title}\nVariant: ${variantCode}`, 'ok');
            else log(`✖ Eroare la salvare: ${resp.info||'(unknown)'}\nEAN: ${raw}`, 'err');
          }
        }
      } catch(e) {
        // ignoră erorile izolate de detectare
      } finally {
        if (scanning) requestAnimationFrame(scanLoop);
      }
    }

    // ===== Legare butoane =====
    startBtn.addEventListener('click', async () => {
      await startCamera();
      const supported = await ensureBarcodeDetector();
      if (!supported) {
        log('Browserul tău nu suportă BarcodeDetector (EAN-13). Încearcă Chrome/Edge pe Android sau iOS actualizat.', 'err');
        return;
      }
      detector = new window.BarcodeDetector({ formats: ['ean_13'] });
      scanning = true;
      requestAnimationFrame(scanLoop);
      startBtn.disabled = true;
    });
    stopBtn.addEventListener('click', () => { scanning = false; stopCamera(); startBtn.disabled = false; });
    torchBtn.addEventListener('click', toggleTorch);

    // avertisment dacă nu e HTTPS
    if (!secureOk()) log('Atenție: deschide pagina pe HTTPS (GitHub Pages e HTTPS implicit).', 'err');
  </script>
</body>
</html>
