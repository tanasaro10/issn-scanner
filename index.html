<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ISSN/ISBN + CIP (OCR) → Google Sheet</title>
  <style>
    :root { --ok:#12a150; --warn:#b00020; --muted:#666; --card:#fff; --line:#e6e6e6; --bg:#fafafa; }
    body { font-family: system-ui, Arial, sans-serif; margin:0; padding:14px; background:var(--bg); color:#111; }
    h2 { margin:0; }
    .top { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .badge { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; font-weight:600; border:1px solid var(--line); background:#f4fdf7; color:var(--ok); }
    .badge::before { content:""; width:8px; height:8px; border-radius:50%; background:var(--ok); display:inline-block; }
    .badge.bad { background:#fff4f4; color:var(--warn); } .badge.bad::before { background:var(--warn); }

    .card { background:var(--card); border:1px solid var(--line); border-radius:12px; padding:14px; margin-top:14px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .grid { display:grid; gap:10px; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); }
    button { padding:10px 14px; border-radius:10px; border:1px solid #ccc; background:#f6f6f6; cursor:pointer; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    input[type=text], input[type=password], textarea { padding:8px; border-radius:8px; border:1px solid #ccc; width:100%; }
    label { font-size:13px; color:#333; }
    .muted { color:var(--muted); font-size:12px; margin-top:6px; }
    .status { padding:10px; border-radius:10px; border:1px dashed var(--line); background:#fff; font-size:14px; }
    .status.wait { background:#fffdf3; border-color:#e8d28b; }
    .status.ok   { background:#f4fdf7; border-color:#cce9d7; }
    .status.err  { background:#fff4f4; border-color:#f0b6b6; }
    .log { font-family: ui-monospace, SFMono-Regular, Consolas, monospace; white-space:pre-wrap; font-size:12px; }
    .ok { color:var(--ok); } .err { color:var(--warn); }

    .camera-shell { overflow:hidden; transition:max-height .25s ease, padding .25s ease, border-width .25s ease; max-height:0; padding:0 0; border:0 solid var(--line); border-radius:12px; background:#000; }
    .camera-shell.active { max-height:70vh; padding:10px; border-width:1px; }
    video, canvas { width:100%; border-radius:8px; background:#000; display:block; }

    .result { display:grid; grid-template-columns: 1fr; gap:6px; }
    .result .label { font-weight:600; color:#333; }
    .actions { display:flex; gap:10px; margin-top:8px; flex-wrap:wrap; }
    .pill { display:inline-flex; align-items:center; gap:8px; border:1px solid var(--line); border-radius:999px; padding:6px 10px; background:#fff; }
    .pill input { scale:1.1; }
    .result-grid { display:grid; gap:10px; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); }
  </style>
  <!-- OCR în browser -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <div class="top">
    <h2>Scanează: Cod (EAN-13) sau Text CIP → Google Sheet</h2>
    <span id="cfgBadge" class="badge bad">Config lipsă</span>
  </div>

  <!-- Config -->
  <details class="card" id="cfgPanel">
    <summary>Config (Script ID & Secret)</summary>
    <div class="grid">
      <div><label>Google Script ID</label><input id="scriptId" type="text" placeholder="AKfycbx..." /><div class="muted">Webhook: <code>https://script.google.com/macros/s/&lt;ID&gt;/exec</code></div></div>
      <div><label>Secret (Token)</label><input id="secret" type="password" placeholder="••••••" /></div>
      <div><label>Device ID (opțional)</label><input id="deviceId" type="text" placeholder="ex. phone01" /></div>
      <div class="row" style="align-items:flex-end">
        <button id="saveCfgBtn">Salvează</button>
        <button id="clearCfgBtn">Șterge</button>
      </div>
    </div>
    <div class="muted">Poți seta din URL o singură dată: <code>?SCRIPT_ID=&amp;SECRET=</code></div>
  </details>

  <!-- Cameră + controale -->
  <div class="card">
    <div class="row">
      <button id="startBtn">Pornește camera</button>
      <button id="stopBtn" disabled>Oprește camera</button>
      <button id="toggleTorchBtn" disabled>Lanternă</button>
      <span class="pill"><input type="checkbox" id="cbContinuous"><label for="cbContinuous">Scanare continuă (EAN)</label></span>
      <span class="pill"><input type="checkbox" id="cbAutoSave"><label for="cbAutoSave">Salvare automată</label></span>
      <span class="pill"><input type="checkbox" id="cbAutoOCR"><label for="cbAutoOCR">OCR fallback automat</label></span>
    </div>
    <div id="cameraShell" class="camera-shell">
      <video id="preview" playsinline muted></video>
      <canvas id="snapCanvas" style="display:none"></canvas>
    </div>
    <div class="row">
      <button id="snapOcrBtn" disabled>Fă poză pt. OCR</button>
      <input id="imgFile" type="file" accept="image/*,.png,.jpg,.jpeg,.webp,.bmp,.tif,.tiff" />
      <button id="ocrFromFileBtn" disabled>OCR din fișier</button>
    </div>
    <div class="muted">Camera scanează EAN-13 (ISBN/ISSN). Dacă nu găsește nimic, apasă „Fă poză pt. OCR” sau bifează „OCR fallback automat”.</div>
  </div>

  <!-- Introducere manuală ISBN -->
  <div class="card">
    <div class="row">
      <div style="flex:1; min-width:260px">
        <label>ISBN (manual — pentru EAN 594…)</label>
        <input id="manualIsbn" type="text" placeholder="978..." />
      </div>
      <div><button id="manualLookupBtn">Caută</button></div>
    </div>
  </div>

  <!-- Status + rezultat curent -->
  <div class="card">
    <div id="statusBox" class="status">Gata.</div>
    <div id="resultBox" class="result" style="display:none; margin-top:8px"></div>
    <div id="resultActions" class="actions" style="display:none">
      <button id="saveBtn">Salvează</button>
      <button id="discardBtn">Nu salva</button>
    </div>
  </div>

  <!-- Text OCR (opțional) -->
  <div class="card">
    <div><strong>Text OCR (opțional – poți lipi aici)</strong></div>
    <textarea id="ocrText" rows="8" placeholder="Aici apare textul rezultat din OCR…"></textarea>
    <div class="actions">
      <button id="parseBtn">Extrage câmpuri din text</button>
      <button id="clearTextBtn">Golește</button>
    </div>
  </div>

  <!-- Jurnal -->
  <div class="card">
    <div><strong>Jurnal</strong></div>
    <div id="last" class="log"></div>
  </div>

<script>
/* ============ Config & utilitare ============ */
const BASE_WEBAPP = "https://script.google.com/macros/s/";
const badge = document.getElementById('cfgBadge');
const scriptIdEl = document.getElementById('scriptId');
const secretEl   = document.getElementById('secret');
const deviceEl   = document.getElementById('deviceId');
const statusBox  = document.getElementById('statusBox');

const cbContinuous = document.getElementById('cbContinuous');
const cbAutoSave   = document.getElementById('cbAutoSave');
const cbAutoOCR    = document.getElementById('cbAutoOCR');

function setBadge(ok){ if(ok){ badge.textContent='Config OK'; badge.classList.remove('bad'); } else { badge.textContent='Config lipsă'; badge.classList.add('bad'); } }
function getCfg(){ return { scriptId: localStorage.getItem('scanner_script_id')||'', secret: localStorage.getItem('scanner_secret')||'', device: localStorage.getItem('scanner_device')||'', cont: localStorage.getItem('pref_continuous')==='1', autosave: localStorage.getItem('pref_autosave')==='1', autoocr: localStorage.getItem('pref_autoocr')==='1' }; }
function saveCfg({scriptId, secret, device}){ if(typeof scriptId==='string') localStorage.setItem('scanner_script_id',scriptId.trim()); if(typeof secret==='string') localStorage.setItem('scanner_secret',secret.trim()); if(typeof device==='string') localStorage.setItem('scanner_device',device.trim()); const c=getCfg(); setBadge(Boolean(c.scriptId && c.secret)); }
function clearCfg(){ localStorage.removeItem('scanner_script_id'); localStorage.removeItem('scanner_secret'); localStorage.removeItem('scanner_device'); scriptIdEl.value=''; secretEl.value=''; deviceEl.value=''; setBadge(false); log('Config ștearsă.', 'ok'); }
function fillInputsFromStorage(){ const {scriptId, secret, device, cont, autosave, autoocr} = getCfg(); scriptIdEl.value=scriptId; secretEl.value=secret; deviceEl.value=device; cbContinuous.checked=cont; cbAutoSave.checked=autosave; cbAutoOCR.checked=autoocr; setBadge(Boolean(scriptId && secret)); }
(function loadFromURL(){ const p=new URLSearchParams(location.search); const sid=p.get('SCRIPT_ID')||p.get('sid')||''; const sec=p.get('SECRET')||p.get('token')||''; let changed=false; if(sid){localStorage.setItem('scanner_script_id',sid);changed=true;} if(sec){localStorage.setItem('scanner_secret',sec);changed=true;} if(changed){ ['SCRIPT_ID','sid','SECRET','token'].forEach(k=>p.delete(k)); const newQs=p.toString(); history.replaceState(null,'',location.pathname+(newQs?('?'+newQs):'')+location.hash); }})();
fillInputsFromStorage();
document.getElementById('saveCfgBtn').addEventListener('click',()=>{ saveCfg({scriptId:scriptIdEl.value,secret:secretEl.value,device:deviceEl.value}); msg('Config salvată local.','ok'); });
document.getElementById('clearCfgBtn').addEventListener('click', clearCfg);
cbContinuous.addEventListener('change', ()=> localStorage.setItem('pref_continuous', cbContinuous.checked ? '1':'0'));
cbAutoSave.addEventListener('change', ()=> localStorage.setItem('pref_autosave',   cbAutoSave.checked ? '1':'0'));
cbAutoOCR .addEventListener('change', ()=> localStorage.setItem('pref_autoocr',    cbAutoOCR.checked  ? '1':'0'));

function msg(text, type=''){ statusBox.className='status ' + (type||''); statusBox.textContent=text; }
function log(text, cls=''){ const last=document.getElementById('last'); last.innerHTML = `<div class="${cls}">${new Date().toLocaleTimeString()} — ${text}</div>` + last.innerHTML; }
const secureOk = () => (window.isSecureContext || location.protocol==='https:' || location.hostname==='localhost');
function buildWebhook(){ const {scriptId}=getCfg(); return scriptId ? (BASE_WEBAPP+scriptId+"/exec") : ''; }

async function postToSheet(payload){
  const {secret, device} = getCfg(); const webhook = buildWebhook();
  if (!webhook || !secret) return { ok:false, info:'Config incompletă (Script ID/Secret).' };
  try {
    const r = await fetch(webhook, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ token:secret, deviceId: device||'', ...payload }) });
    const j = await r.json().catch(()=> ({})); return { ok: !!j.ok, info: j.error || '' };
  } catch (e1) {
    try {
      const form = new URLSearchParams(); form.set('token', secret); form.set('deviceId', device||''); Object.entries(payload).forEach(([k,v])=> form.set(k, (v==null)?'':(Array.isArray(v)?v.join(', '):String(v))));
      const r2 = await fetch(webhook, { method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body: form.toString() });
      const j2 = await r2.json().catch(()=> ({})); return { ok: (j2.ok===true)||r2.ok, info: j2.error || '' };
    } catch (e2) {
      try {
        const form = new URLSearchParams(); form.set('token', secret); form.set('deviceId', device||''); Object.entries(payload).forEach(([k,v])=> form.set(k,(v==null)?'':(Array.isArray(v)?v.join(', '):String(v))));
        await fetch(webhook, { method:'POST', mode:'no-cors', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body: form.toString() });
        return { ok:true, info:'sent-no-cors' };
      } catch (e3) { return { ok:false, info:String(e3) }; }
    }
  }
}

/* ============ Cameră + BarcodeDetector ============ */
const preview = document.getElementById('preview');
const startBtn = document.getElementById('startBtn');
const stopBtn  = document.getElementById('stopBtn');
const torchBtn = document.getElementById('toggleTorchBtn');
const cameraShell  = document.getElementById('cameraShell');
const snapCanvas = document.getElementById('snapCanvas');

let stream=null, detector=null, scanning=false;
let lastEan=null, lastAt=0;
let pendingPayload=null;

async function ensureBarcodeDetector(){ if (!('BarcodeDetector' in window)) return false; try{ const f=await window.BarcodeDetector.getSupportedFormats(); return f.includes('ean_13')||f.includes('ean13'); }catch{ return false; } }
async function startCamera(){
  if (!secureOk()) { msg('Pagina nu este pe HTTPS — accesul la cameră va fi blocat.', 'err'); return; }
  try{
    stream = await navigator.mediaDevices.getUserMedia({ video:{facingMode:{ideal:'environment'}}, audio:false });
    preview.srcObject=stream; await preview.play(); stopBtn.disabled=true; // rămâne disabled până pregătim detectorul
    cameraShell.classList.add('active');
    try{ const track=stream.getVideoTracks?.()[0]; const caps=track?.getCapabilities?.(); if (caps && 'torch' in caps) torchBtn.disabled=false; }catch{}
    // pregătim detector
    const ok = await ensureBarcodeDetector();
    if (!ok) {
      msg('Browserul nu suportă BarcodeDetector (EAN-13). Poți folosi OCR.', 'err');
      stopBtn.disabled=false;
      snapOcrBtn.disabled=false;
      return;
    }
    detector = new window.BarcodeDetector({ formats:['ean_13'] });
    scanning = true; startBtn.disabled = true; stopBtn.disabled=false;
    snapOcrBtn.disabled=false; // putem face poză oricând
    msg('Scanez EAN-13…', '');
    requestAnimationFrame(scanLoop);
  }catch(e){
    msg('Eroare pornire cameră: '+(e.message||e.name), 'err');
  }
}
function stopCamera(){ try{ stream?.getTracks?.().forEach(t=>t.stop()); }catch{} stream=null; preview.srcObject=null; scanning=false; stopBtn.disabled=true; torchBtn.disabled=true; cameraShell.classList.remove('active'); startBtn.disabled=false; }
async function toggleTorch(){ const track=stream?.getVideoTracks?.()[0]; if(!track) return; try{ const caps=track.getCapabilities?.(); if(!caps||!('torch' in caps)) return msg('Torch nesuportat pe acest device.', 'err'); const st=track.getSettings?.()||{}; await track.applyConstraints({advanced:[{torch:!st.torch}]}); }catch(e){ msg('Nu pot controla lanterna: '+e.message, 'err'); } }

startBtn.addEventListener('click', startCamera);
stopBtn.addEventListener('click', ()=>{ scanning=false; stopCamera(); msg('Camera oprită.', ''); });

function showResultCard(pl){
  const resultBox    = document.getElementById('resultBox');
  const resultActions= document.getElementById('resultActions');
  resultBox.style.display='grid';
  resultActions.style.display = cbAutoSave.checked ? 'none' : 'flex';
  resultBox.innerHTML = `
    <div><span class="label">Tip:</span> ${(pl.type||'').toUpperCase()}</div>
    ${pl.ean ? `<div><span class="label">EAN:</span> ${pl.ean}</div>`:''}
    ${pl.isbn? `<div><span class="label">ISBN:</span> ${pl.isbn}</div>`:''}
    ${pl.issn? `<div><span class="label">ISSN:</span> ${pl.issn}</div>`:''}
    ${pl.title? `<div><span class="label">Titlu:</span> ${pl.title}</div>`:''}
    ${pl.authors? `<div><span class="label">Autori:</span> ${pl.authors}</div>`:''}
    ${pl.publisher? `<div><span class="label">Editura:</span> ${pl.publisher}</div>`:''}
    ${pl.publishedDate? `<div><span class="label">Data:</span> ${pl.publishedDate}</div>`:''}
    ${pl.year? `<div><span class="label">An:</span> ${pl.year}</div>`:''}
    ${pl.pages? `<div><span class="label">Pagini:</span> ${pl.pages}</div>`:''}
    ${pl.source? `<div><span class="label">Sursă:</span> ${pl.source}</div>`:''}
  `;
}

function hideResultCard(){ document.getElementById('resultBox').style.display='none'; document.getElementById('resultActions').style.display='none'; document.getElementById('resultBox').innerHTML=''; }

async function handlePayloadAfterLookup(pl){
  pendingPayload = pl;
  showResultCard(pl);
  if (cbAutoSave.checked) {
    const resp = await postToSheet(pl);
    if (resp.ok) { msg('✔ Salvat automat.', 'ok'); log(`✔ Salvat [${pl.type?.toUpperCase()}] ${pl.title||pl.isbn||pl.issn||''}`, 'ok'); }
    else { msg('✖ Eroare la salvare: '+(resp.info||'(unknown)'), 'err'); log(`✖ Eroare la salvare: ${resp.info||'(unknown)'}`, 'err'); }
  } else {
    msg('Gata. Verifică detaliile și apasă „Salvează” sau „Nu salva”.', 'ok');
  }
}

/* Clasificare simplă */
function classifyPublication(ean13){ if(!/^\d{13}$/.test(ean13)) return {type:'other'}; if(ean13.startsWith('977')) return {type:'issn'}; if(ean13.startsWith('978')||ean13.startsWith('979')) return {type:'isbn'}; return {type:'other'}; }
function issnFromEan13(ean){
  if (!/^\d{13}$/.test(ean) || !ean.startsWith('977')) return null;
  const issn7 = ean.substring(3,10), variant = ean.substring(10,12);
  const w=[8,7,6,5,4,3,2]; let s=0; for(let i=0;i<7;i++) s += (+issn7[i])*w[i];
  const r=s%11, cd=(11-r)%11, check=(cd===10)?'X':String(cd);
  return { issn: issn7.slice(0,4)+'-'+issn7.slice(4)+check, variantCode: variant };
}

/* Lookups (local minimal) */
async function safeJson(url, opts){ try{ const r=await fetch(url, opts||{}); if(!r.ok) throw 0; return await r.json(); } catch{ return null; } }
async function lookupISBNLocal(isbn){
  const g = await safeJson(`https://www.googleapis.com/books/v1/volumes?q=isbn:${encodeURIComponent(isbn)}`);
  const it = g?.items?.[0], v=it?.volumeInfo||null;
  if (v){ return { title:v.title||'—', subtitle:v.subtitle||'', authors:Array.isArray(v.authors)?v.authors:[], publisher:v.publisher||'', publishedDate:v.publishedDate||'', pages:v.pageCount||'', language:v.language||'', categories:Array.isArray(v.categories)?v.categories.join(', '):'', cover:v.imageLinks?.thumbnail||'', source:'googlebooks' }; }
  const s = await safeJson(`https://openlibrary.org/search.json?isbn=${encodeURIComponent(isbn)}`); const d=s?.docs?.[0];
  if (d){ return { title:d.title||'—', authors:Array.isArray(d.author_name)?d.author_name:[], publisher:Array.isArray(d.publisher)?d.publisher.slice(0,3).join(', '):(d.publisher||''), publishedDate:d.first_publish_year?String(d.first_publish_year):(d.publish_date&&d.publish_date[0])||'', pages:d.number_of_pages_median||'', source:'openlibrary_search' }; }
  return null;
}
async function lookupISSNLocal(issn){
  const j = await safeJson(`https://api.crossref.org/journals/${encodeURIComponent(issn)}`);
  if (j?.message) return { title:j.message.title||'—', publisher:j.message.publisher||'', source:'crossref_journals' };
  return null;
}

/* Scan loop — cu fallback opțional la OCR */
async function scanLoop(){
  if (!detector || !scanning) return;
  let found=false;
  try{
    const barcodes = await detector.detect(preview);
    if (barcodes && barcodes.length){
      for (const b of barcodes){
        const raw = String(b.rawValue||'').trim(); if (!raw) continue;
        const now=Date.now(); if (raw===lastEan && (now-lastAt)<2000) continue;
        lastEan=raw; lastAt=now; found=true;

        const cls = classifyPublication(raw);
        if (cls.type==='other'){ log(`EAN non-publicație: ${raw}`, 'err'); msg('Cod non-publicație. Poți încerca OCR.', 'err'); if (!cbContinuous.checked) { scanning=false; } break; }

        let pl = { type: cls.type, ean: raw, issn:'', isbn:'', title:'—', authors:'', publisher:'', publishedDate:'', pages:'', source:'' };
        msg('Caut informații…', 'wait');
        if (cls.type==='issn'){
          const p = issnFromEan13(raw);
          if (!p){ msg('ISSN derivat invalid.', 'err'); break; }
          pl.issn=p.issn;
          let det = await lookupISSNLocal(p.issn);
          pl.title = det?.title || '—'; pl.publisher = det?.publisher || ''; pl.source = det?.source || '';
        } else {
          pl.isbn = raw;
          let det = await lookupISBNLocal(raw);
          pl.title = det?.title || '—';
          pl.authors = Array.isArray(det?.authors)? det.authors.join(', '):(det?.authors||'');
          pl.publisher = det?.publisher || '';
          pl.publishedDate = det?.publishedDate || '';
          pl.pages = det?.pages || '';
          pl.source = det?.source || '';
        }

        await handlePayloadAfterLookup(pl);
        if (!cbContinuous.checked){ scanning=false; }
        break;
      }
    }
  }catch(e){ /* ignore */ }
  finally {
    if (!found && cbAutoOCR.checked) {
      // n-am găsit nimic în cadrul curent → încearcă OCR
      await ocrFromCurrentFrame(true);
      if (!cbContinuous.checked) { scanning=false; }
    }
    if (scanning) requestAnimationFrame(scanLoop);
  }
}

/* ============ OCR (Tesseract) + parsare CIP ============ */
const snapOcrBtn = document.getElementById('snapOcrBtn');
const imgFile    = document.getElementById('imgFile');
const ocrFromFileBtn = document.getElementById('ocrFromFileBtn');
const ocrText    = document.getElementById('ocrText');
const parseBtn   = document.getElementById('parseBtn');
const clearTextBtn = document.getElementById('clearTextBtn');
const saveBtn    = document.getElementById('saveBtn');
const discardBtn = document.getElementById('discardBtn');

let tessWorker=null;
async function ensureWorker(){
  if(!tessWorker){
    msg('Inițializez OCR…','wait');
    tessWorker = await Tesseract.createWorker('ron+eng');
  }
}

function cleanIsbn(raw){ if(!raw) return ''; let s=raw.replace(/[^0-9Xx]/g,'').toUpperCase(); if(s.length===10||s.length===13) return s; return s; }
function cleanIssn(raw){ if(!raw) return ''; let s=raw.replace(/[^0-9Xx]/g,'').toUpperCase(); if(s.length===8){ return s.slice(0,4)+'-'+s.slice(4);} return s; }

function normalizeOCR(t){
  if(!t) return '';
  let s=t.replace(/\r/g,'');
  s = s.replace(/-\n/g,'');                 // liant de rând
  s = s.replace(/[ \t]+\n/g,'\n');
  s = s.replace(/\n{3,}/g,'\n\n');
  s = s.replace(/[ \t]{2,}/g,' ');
  s = s.replace(/I S B N/gi,'ISBN').replace(/I S S N/gi,'ISSN');
  return s.trim();
}

function parseCIP(text){
  const src = (text||'').trim();
  const lower = src.toLowerCase();

  // ISBN / ISSN
  let isbnMatch = src.match(/ISBN(?:\s*13)?\s*[:]?\s*([0-9Xx][0-9\-\sXx]{7,})/);
  if(!isbnMatch){ isbnMatch = src.match(/\b(97[89][0-9\-\s]{8,}[0-9Xx])\b/); }
  const isbn = cleanIsbn(isbnMatch?.[1]||'');

  let issnMatch = src.match(/ISSN\s*[:]?\s*([0-9Xx][0-9\-\sXx]{3,})/i);
  const issn = cleanIssn(issnMatch?.[1]||'');

  // Titlu / Autori
  let block = src;
  const idxCIP = lower.indexOf('descrierea cip');
  if(idxCIP>=0) block = src.slice(idxCIP).split('\n').slice(0,12).join('\n');

  let title='', authors='';
  const m1 = block.match(/^\s*([^\n\/]{4,})\s*\/\s*([^\n\.]{3,})/m);
  if(m1){ title = m1[1].trim().replace(/\s{2,}/g,' '); authors = m1[2].trim(); }
  if(!authors){
    const mAu = block.match(/\b(Autor(?:i)?|de)\s*[:]*\s*([^\n\.]{3,})/i);
    if(mAu) authors = mAu[2].trim();
  }
  if(!title){
    const lines = block.split('\n').map(s=>s.trim()).filter(s=>s && s.length>4);
    title = (lines[0]||'').replace(/\s{2,}/g,' ').replace(/[:\.\-–—]\s*$/,'');
  }
  authors = authors.replace(/\s{2,}/g,' ').replace(/\s*;\s*/g,', ').replace(/\s*,\s*,/g,', ').trim();
  authors = authors.replace(/\b(coord\.?|editori?|eds?\.)\b/gi,'').replace(/\s{2,}/g,' ').trim();

  // Editură + an
  let publisher='', year='';
  const placePub = block.match(/:\s*([^,\n]{2,}?)\s*,\s*(\d{4})/);
  if(placePub){ publisher = placePub[1].trim(); year = placePub[2]; }
  if(!publisher){
    const mEd = block.match(/Editura\s+([^\.,\n]{2,})/i);
    if(mEd) publisher = mEd[1].trim();
  }
  if(!year){
    const years = src.match(/\b(19|20)\d{2}\b/g);
    if(years) year = years[0];
  }

  let type = isbn ? 'isbn' : (issn ? 'issn' : 'cip');
  return { type, title, authors, publisher, year, isbn, issn };
}

async function ocrImageSource(imageBitmap){
  await ensureWorker();
  // desenează în canvas temporar la lățime max 1600px pentru OCR ok
  const maxW = 1600, scale = Math.min(1, maxW / imageBitmap.width);
  const cw = Math.round(imageBitmap.width*scale), ch = Math.round(imageBitmap.height*scale);
  const tmp = document.createElement('canvas'); tmp.width=cw; tmp.height=ch;
  const tctx = tmp.getContext('2d'); tctx.drawImage(imageBitmap, 0, 0, cw, ch);
  msg('Rulez OCR…','wait');
  const { data:{ text } } = await tessWorker.recognize(tmp);
  const clean = normalizeOCR(text);
  ocrText.value = clean;
  msg('OCR terminat. Apasă „Extrage câmpuri din text”.','ok');
  log('OCR complet (din imagine).','ok');
}

async function ocrFromCurrentFrame(silent=false){
  if(!preview.videoWidth){ if(!silent) msg('Camera nu este activă pentru OCR.', 'err'); return; }
  await ensureWorker();
  const cw = preview.videoWidth, ch = preview.videoHeight;
  snapCanvas.width=cw; snapCanvas.height=ch;
  const c = snapCanvas.getContext('2d'); c.drawImage(preview, 0, 0, cw, ch);
  msg('Rulez OCR pe cadru…','wait');
  const { data:{ text } } = await tessWorker.recognize(snapCanvas);
  const clean = normalizeOCR(text);
  if (!silent) { ocrText.value = clean; msg('OCR din cadru finalizat. „Extrage câmpuri”.','ok'); }
  // dacă e fallback automat, încerci direct parsarea+salvarea
  if (silent) {
    const r = parseCIP(clean);
    const pl = { type:r.type, ean:'', issn:r.issn||'', isbn:r.isbn||'', title:r.title||'—', authors:r.authors||'', publisher:r.publisher||'', publishedDate:'', year:r.year||'', pages:'', source:'ocr' };
    if (r.isbn || r.issn || r.title) {
      await handlePayloadAfterLookup(pl);
    } else {
      msg('OCR nu a extras nimic util din cadru.', 'err');
    }
  }
}

document.getElementById('parseBtn').addEventListener('click', ()=>{
  const t = ocrText.value;
  if(!t){ msg('Nu există text pentru parsare. Rulează OCR sau lipește text.','err'); return; }
  const r = parseCIP(t);
  const pl = { type:r.type, ean:'', issn:r.issn||'', isbn:r.isbn||'', title:r.title||'—', authors:r.authors||'', publisher:r.publisher||'', publishedDate:'', year:r.year||'', pages:'', source:'ocr' };
  showResultCard(pl); pendingPayload = pl;
  if (cbAutoSave.checked) {
    postToSheet(pl).then(resp=>{
      if (resp.ok) { msg('✔ Salvat automat (OCR).','ok'); log(`✔ Salvat [OCR] ${pl.title||pl.isbn||pl.issn||''}`,'ok'); }
      else { msg('✖ Eroare la salvare: '+(resp.info||'(unknown)'),'err'); }
    });
  } else {
    msg('Extragere completă (OCR). Verifică și salvează.','ok');
  }
});

clearTextBtn.addEventListener('click', ()=>{ ocrText.value=''; msg('Text golit.',''); });

const ocrFromFileEnable = ()=>{ ocrFromFileBtn.disabled = !imgFile.files?.[0]; };
imgFile.addEventListener('change', ()=>{ ocrFromFileEnable(); });
ocrFromFileBtn.addEventListener('click', async ()=>{
  const f = imgFile.files?.[0]; if(!f){ msg('Alege un fișier imagine.','err'); return; }
  const bmp = await createImageBitmap(f); await ocrImageSource(bmp);
});
snapOcrBtn.addEventListener('click', ()=> ocrFromCurrentFrame(false));

/* Salvare / Nu salva */
document.getElementById('saveBtn').addEventListener('click', async ()=>{
  if (!pendingPayload) return;
  const resp = await postToSheet(pendingPayload);
  if (resp.ok) { msg('✔ Salvat.', 'ok'); log(`✔ Salvat [${pendingPayload.type?.toUpperCase()}] ${pendingPayload.title||pendingPayload.isbn||pendingPayload.issn||''}`, 'ok'); pendingPayload = null; hideResultCard(); }
  else { msg('✖ Eroare la salvare: '+(resp.info||'(unknown)'), 'err'); }
});
document.getElementById('discardBtn').addEventListener('click', ()=>{ pendingPayload=null; hideResultCard(); msg('Intrare ignorată.',''); });

/* Manual ISBN (păstrat) */
document.getElementById('manualLookupBtn').addEventListener('click', async ()=>{
  const v = document.getElementById('manualIsbn').value.trim().replace(/[^\dXx]/g,'');
  if (!v){ msg('Introdu un ISBN valid.', 'err'); return; }
  msg('Caut informații…','wait'); hideResultCard();
  let det = await lookupISBNLocal(v);
  let pl = { type:'isbn', ean:'', issn:'', isbn: v, title: det?.title||'—', authors: Array.isArray(det?.authors)? det.authors.join(', '):(det?.authors||''), publisher: det?.publisher||'', publishedDate: det?.publishedDate||'', pages: det?.pages||'', source: det?.source||'' };
  await handlePayloadAfterLookup(pl);
});

/* Inițializări UI */
const ocrFromFileBtnEl = document.getElementById('ocrFromFileBtn');
ocrFromFileEnable();
if (!secureOk()) msg('Atenție: deschide pagina pe HTTPS (GitHub Pages e HTTPS implicit).', 'err');
</script>
</body>
</html>
