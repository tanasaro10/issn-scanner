<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CIP → Google Sheet (ISBN/ISSN din pagina 2/4)</title>
  <style>
    :root { --ok:#12a150; --warn:#b00020; --muted:#666; --card:#fff; --line:#e6e6e6; --bg:#fafafa; }
    body { font-family: system-ui, Arial, sans-serif; margin:0; padding:14px; background:var(--bg); color:#111; }
    h2 { margin:0; }
    .top { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .badge { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; font-weight:600; border:1px solid var(--line); background:#f4fdf7; color:var(--ok); }
    .badge::before { content:""; width:8px; height:8px; border-radius:50%; background:var(--ok); display:inline-block; }
    .badge.bad { background:#fff4f4; color:var(--warn); } .badge.bad::before { background:var(--warn); }

    .card { background:var(--card); border:1px solid var(--line); border-radius:12px; padding:14px; margin-top:14px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .col { display:flex; flex-direction:column; gap:8px; }
    button { padding:10px 14px; border-radius:10px; border:1px solid #ccc; background:#f6f6f6; cursor:pointer; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    input[type=text], input[type=password], textarea { padding:8px; border-radius:8px; border:1px solid #ccc; width:100%; }
    label { font-size:13px; color:#333; }
    .muted { color:var(--muted); font-size:12px; margin-top:6px; }
    .status { padding:10px; border-radius:10px; border:1px dashed var(--line); background:#fff; font-size:14px; }
    .status.wait { background:#fffdf3; border-color:#e8d28b; }
    .status.ok { background:#f4fdf7; border-color:#cce9d7; }
    .status.err { background:#fff4f4; border-color:#f0b6b6; }
    .log { font-family: ui-monospace, SFMono-Regular, Consolas, monospace; white-space:pre-wrap; font-size:12px; }
    .ok { color:var(--ok); } .err { color:var(--warn); }

    .pill { display:inline-flex; align-items:center; gap:8px; border:1px solid var(--line); border-radius:999px; padding:6px 10px; background:#fff; }
    .pill input { scale:1.1; }

    /* canvas/capture */
    .capture { display:grid; grid-template-columns:1fr; gap:10px; }
    .stage { position:relative; background:#000; border-radius:10px; overflow:hidden; border:1px solid var(--line); }
    video, canvas { width:100%; display:block; background:#000; }
    .crop-hint { position:absolute; right:8px; bottom:8px; color:#fff; background:rgba(0,0,0,.5); padding:4px 8px; border-radius:8px; font-size:12px; }
    .toolbar { display:flex; gap:8px; flex-wrap:wrap; }

    .grid { display:grid; gap:10px; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); }
    .field { display:flex; flex-direction:column; gap:4px; }
    .actions { display:flex; gap:10px; margin-top:8px; flex-wrap:wrap; }

    details.config summary { cursor:pointer; font-weight:600; }
    details.config[open] summary { margin-bottom:8px; }

    .result-grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); gap:10px; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Consolas, monospace; background:#f3f3f3; border:1px solid #ddd; border-radius:6px; padding:2px 6px; }
  </style>
  <!-- Tesseract.js (OCR în browser) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <div class="top">
    <h2>CIP → Google Sheet</h2>
    <span id="cfgBadge" class="badge bad">Config lipsă</span>
  </div>

  <!-- Config -->
  <details class="card config" id="cfgPanel">
    <summary>Config (Script ID & Secret)</summary>
    <div class="grid">
      <div class="field">
        <label>Google Script ID</label>
        <input id="scriptId" type="text" placeholder="AKfycbx..." />
        <div class="muted">Webhook: <code>https://script.google.com/macros/s/&lt;ID&gt;/exec</code></div>
      </div>
      <div class="field">
        <label>Secret (Token)</label>
        <input id="secret" type="password" placeholder="••••••" />
      </div>
      <div class="field">
        <label>Device ID (opțional)</label>
        <input id="deviceId" type="text" placeholder="ex. phone01" />
      </div>
      <div class="col" style="align-self:flex-end;">
        <div class="actions">
          <button id="saveCfgBtn">Salvează</button>
          <button id="clearCfgBtn">Șterge</button>
        </div>
        <div class="muted">Poți seta o singură dată din URL: <code>?SCRIPT_ID=&amp;SECRET=</code></div>
      </div>
    </div>
  </details>

  <!-- Captură / Upload -->
  <div class="card">
    <div class="row">
      <span class="pill"><input type="checkbox" id="cbAutoSave"><label for="cbAutoSave">Salvare automată după extragere</label></span>
      <span class="pill"><input type="checkbox" id="cbKeepCamera"><label for="cbKeepCamera">Ține camera deschisă</label></span>
    </div>
    <div class="capture">
      <div class="toolbar">
        <button id="openCameraBtn">Deschide camera</button>
        <button id="snapBtn" disabled>Fă poză</button>
        <button id="closeCameraBtn" disabled>Închide camera</button>
        <input id="fileInput" type="file" accept="image/*,.png,.jpg,.jpeg,.webp,.bmp,.tif,.tiff" />
        <button id="rotateBtn" disabled>Rotește 90°</button>
        <button id="ocrBtn" disabled>OCR pe întreaga imagine</button>
        <button id="ocrCropBtn" disabled>OCR pe selecția decupată</button>
      </div>
      <div class="stage" id="stage">
        <video id="video" playsinline muted></video>
        <canvas id="canvas" aria-label="canvas imagine"></canvas>
        <div class="crop-hint">Trage cu mouse-ul pentru a selecta zona CIP</div>
      </div>
      <div class="muted">Ideal: fotografiază drept pagina 2/4 cu „Descrierea CIP a Bibliotecii Naționale a României”. Selectează zona de text, apoi OCR.</div>
    </div>
  </div>

  <!-- Text OCR + parsare -->
  <div class="card">
    <div class="row" style="align-items:flex-start;">
      <div style="flex:1; min-width:280px">
        <label>Text OCR (poți lipi aici dacă ai deja textul)</label>
        <textarea id="ocrText" rows="10" placeholder="Aici va apărea textul CIP…"></textarea>
        <div class="actions">
          <button id="parseBtn">Extrage câmpuri</button>
          <button id="clearTextBtn">Golește</button>
        </div>
      </div>
      <div style="flex:1; min-width:280px">
        <div><strong>Rezultat (editabil înainte de salvare)</strong></div>
        <div class="result-grid" style="margin-top:8px">
          <div class="field"><label>Tip</label><input id="outType" type="text" placeholder="isbn/issn" /></div>
          <div class="field"><label>Titlu</label><input id="outTitle" type="text" /></div>
          <div class="field"><label>Autori</label><input id="outAuthors" type="text" placeholder="nume, prenume; ..." /></div>
          <div class="field"><label>Editura</label><input id="outPublisher" type="text" /></div>
          <div class="field"><label>An</label><input id="outYear" type="text" /></div>
          <div class="field"><label>ISBN</label><input id="outISBN" type="text" /></div>
          <div class="field"><label>ISSN (dacă e cazul)</label><input id="outISSN" type="text" /></div>
        </div>
        <div class="actions">
          <button id="saveBtn" disabled>Salvează</button>
          <button id="discardBtn" disabled>Nu salva</button>
        </div>
      </div>
    </div>
    <div id="statusBox" class="status">Gata.</div>
  </div>

  <!-- Jurnal -->
  <div class="card">
    <div><strong>Jurnal</strong></div>
    <div id="last" class="log"></div>
  </div>

<script>
/* ========= Config ========= */
const BASE_WEBAPP = "https://script.google.com/macros/s/";
const badge = document.getElementById('cfgBadge');
const scriptIdEl = document.getElementById('scriptId');
const secretEl   = document.getElementById('secret');
const deviceEl   = document.getElementById('deviceId');
const cbAutoSave = document.getElementById('cbAutoSave');
const cbKeepCamera = document.getElementById('cbKeepCamera');

function setBadge(ok){ if(ok){ badge.textContent='Config OK'; badge.classList.remove('bad'); } else { badge.textContent='Config lipsă'; badge.classList.add('bad'); } }
function getCfg(){ return { scriptId: localStorage.getItem('scanner_script_id')||'', secret: localStorage.getItem('scanner_secret')||'', device: localStorage.getItem('scanner_device')||'', autosave: localStorage.getItem('pref_autosave')==='1', keepcam: localStorage.getItem('pref_keepcam')==='1' }; }
function saveCfg({scriptId, secret, device}){
  if(typeof scriptId==='string') localStorage.setItem('scanner_script_id',scriptId.trim());
  if(typeof secret==='string') localStorage.setItem('scanner_secret',secret.trim());
  if(typeof device==='string') localStorage.setItem('scanner_device',device.trim());
  const c=getCfg(); setBadge(Boolean(c.scriptId && c.secret));
}
function clearCfg(){
  localStorage.removeItem('scanner_script_id');
  localStorage.removeItem('scanner_secret');
  localStorage.removeItem('scanner_device');
  scriptIdEl.value=''; secretEl.value=''; deviceEl.value='';
  setBadge(false); log('Config ștearsă.','ok');
}
function buildWebhook(){ const {scriptId}=getCfg(); return scriptId ? (BASE_WEBAPP+scriptId+"/exec") : ''; }
(function loadFromURL(){
  const p=new URLSearchParams(location.search);
  const sid=p.get('SCRIPT_ID')||p.get('scriptId')||p.get('sid')||p.get('SID')||'';
  const sec=p.get('SECRET')||p.get('secret')||p.get('token')||p.get('TOKEN')||'';
  let changed=false; if(sid){localStorage.setItem('scanner_script_id',sid);changed=true;} if(sec){localStorage.setItem('scanner_secret',sec);changed=true;}
  if(changed){ ['SCRIPT_ID','scriptId','sid','SID','SECRET','secret','token','TOKEN'].forEach(k=>p.delete(k)); const newQs=p.toString(); history.replaceState(null,'',location.pathname+(newQs?('?'+newQs):'')+location.hash); }
})();
function fillInputsFromStorage(){
  const {scriptId, secret, device, autosave, keepcam} = getCfg();
  scriptIdEl.value=scriptId; secretEl.value=secret; deviceEl.value=device;
  cbAutoSave.checked = autosave; cbKeepCamera.checked = keepcam;
  setBadge(Boolean(scriptId && secret));
}
fillInputsFromStorage();
document.getElementById('saveCfgBtn').addEventListener('click',()=>{ saveCfg({scriptId:scriptIdEl.value,secret:secretEl.value,device:deviceEl.value}); msg('Config salvată local.','ok'); });
document.getElementById('clearCfgBtn').addEventListener('click', clearCfg);
cbAutoSave.addEventListener('change', ()=> localStorage.setItem('pref_autosave', cbAutoSave.checked ? '1':'0'));
cbKeepCamera.addEventListener('change', ()=> localStorage.setItem('pref_keepcam', cbKeepCamera.checked ? '1':'0'));

/* ========= UI utils ========= */
const statusBox = document.getElementById('statusBox');
function msg(text, type=''){ statusBox.className='status '+(type||''); statusBox.textContent=text; }
function log(text, cls=''){ const last=document.getElementById('last'); last.innerHTML = `<div class="${cls}">${new Date().toLocaleTimeString()} — ${text}</div>` + last.innerHTML; }
const secureOk = () => (window.isSecureContext || location.protocol==='https:' || location.hostname==='localhost');

/* ========= Salvare către Script ========= */
async function postToSheet(payload){
  const {secret, device} = getCfg(); const webhook = buildWebhook();
  if (!webhook || !secret) return { ok:false, info:'Config incompletă (Script ID/Secret).' };

  // 1) JSON
  try {
    const r = await fetch(webhook, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ token:secret, deviceId: device||'', ...payload }) });
    const j = await r.json().catch(()=> ({})); return { ok: !!j.ok, info: j.error || '' };
  } catch (e1) {
    // 2) x-www-form-urlencoded
    try {
      const form = new URLSearchParams(); form.set('token', secret); form.set('deviceId', device||''); Object.entries(payload).forEach(([k,v])=> form.set(k, (v==null)?'':(Array.isArray(v)?v.join(', '):String(v))));
      const r2 = await fetch(webhook, { method:'POST', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body: form.toString() });
      const j2 = await r2.json().catch(()=> ({})); return { ok: (j2.ok===true)||r2.ok, info: j2.error || '' };
    } catch (e2) {
      // 3) no-cors
      try {
        const form = new URLSearchParams(); form.set('token', secret); form.set('deviceId', device||''); Object.entries(payload).forEach(([k,v])=> form.set(k,(v==null)?'':(Array.isArray(v)?v.join(', '):String(v))));
        await fetch(webhook, { method:'POST', mode:'no-cors', headers:{'Content-Type':'application/x-www-form-urlencoded'}, body: form.toString() });
        return { ok:true, info:'sent-no-cors' };
      } catch (e3) { return { ok:false, info:String(e3) }; }
    }
  }
}

/* ========= Camera / Canvas / Crop ========= */
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const openCameraBtn = document.getElementById('openCameraBtn');
const closeCameraBtn = document.getElementById('closeCameraBtn');
const snapBtn = document.getElementById('snapBtn');
const rotateBtn = document.getElementById('rotateBtn');
const ocrBtn = document.getElementById('ocrBtn');
const ocrCropBtn = document.getElementById('ocrCropBtn');
const fileInput = document.getElementById('fileInput');

let stream=null, rotation=0;
let imgBitmap=null; // imaginea curentă afișată în canvas (din poză/camera)
let cropStart=null, cropEnd=null;

function resizeCanvasTo(bitmap){
  const maxW = Math.min(1600, window.innerWidth*1.5);
  const scale = Math.min(1, maxW / bitmap.width);
  canvas.width = Math.round(bitmap.width*scale);
  canvas.height= Math.round(bitmap.height*scale);
}

function render(){
  if(!imgBitmap) return;
  // redare cu rotație în multipli de 90°
  const turns = ((rotation%360)+360)%360/90|0;
  const w = imgBitmap.width, h = imgBitmap.height;
  let dW=w, dH=h;
  if(turns%2===1){ dW=h; dH=w; }
  const maxW = Math.min(1600, window.innerWidth*1.5);
  const scale = Math.min(1, maxW / dW);
  canvas.width = Math.round(dW*scale);
  canvas.height= Math.round(dH*scale);

  ctx.save();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.translate(canvas.width/2, canvas.height/2);
  ctx.rotate(turns * Math.PI/2);
  const drawW = Math.round(w*scale);
  const drawH = Math.round(h*scale);
  if(turns%2===0){
    ctx.drawImage(imgBitmap, -drawW/2, -drawH/2, drawW, drawH);
  } else {
    ctx.drawImage(imgBitmap, -drawH/2, -drawW/2, drawH, drawW);
  }
  ctx.restore();

  // desenează selecția dacă există
  if(cropStart && cropEnd){
    const x = Math.min(cropStart.x, cropEnd.x), y=Math.min(cropStart.y, cropEnd.y);
    const w = Math.abs(cropStart.x - cropEnd.x), h=Math.abs(cropStart.y - cropEnd.y);
    ctx.save();
    ctx.strokeStyle = '#00ff99';
    ctx.lineWidth = 2;
    ctx.strokeRect(x+.5,y+.5,w,h);
    ctx.restore();
  }
}

async function startCamera(){
  if (!secureOk()) { msg('Deschide pe HTTPS (sau localhost) pentru acces cameră.','err'); return; }
  try{
    stream = await navigator.mediaDevices.getUserMedia({ video:{facingMode:{ideal:'environment'}}, audio:false });
    video.srcObject = stream; await video.play();
    snapBtn.disabled=false; closeCameraBtn.disabled=false;
    msg('Camera pornită. Încadrează pagina CIP și fă poză.', '');
  }catch(e){
    msg('Eroare cameră: '+(e.message||e.name),'err');
  }
}
function stopCamera(){
  try{ stream?.getTracks?.().forEach(t=>t.stop()); }catch{}
  stream=null; video.srcObject=null;
  snapBtn.disabled=true; closeCameraBtn.disabled=true;
}

async function paintFromVideo(){
  if(!video.videoWidth) return;
  const bmp = await createImageBitmap(video);
  imgBitmap = bmp; rotation=0; cropStart=null; cropEnd=null;
  render();
  ocrBtn.disabled=false; ocrCropBtn.disabled=false; rotateBtn.disabled=false; enableSave(false);
}

fileInput.addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; if(!f) return;
  const bmp = await createImageBitmap(f);
  imgBitmap = bmp; rotation=0; cropStart=null; cropEnd=null;
  render();
  ocrBtn.disabled=false; ocrCropBtn.disabled=false; rotateBtn.disabled=false; enableSave(false);
  msg('Imagine încărcată. Poți selecta zona CIP și rula OCR.','');
});

openCameraBtn.addEventListener('click', startCamera);
closeCameraBtn.addEventListener('click', ()=>{ stopCamera(); msg('Camera închisă.',''); });
snapBtn.addEventListener('click', async ()=>{ await paintFromVideo(); if(!cbKeepCamera.checked) stopCamera(); });

rotateBtn.addEventListener('click', ()=>{ rotation = (rotation+90)%360; render(); });

/* Crop cu mouse */
canvas.addEventListener('mousedown', (e)=>{
  const rect = canvas.getBoundingClientRect();
  cropStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  cropEnd = null;
});
canvas.addEventListener('mousemove', (e)=>{
  if(!cropStart) return;
  const rect = canvas.getBoundingClientRect();
  cropEnd = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  render();
});
canvas.addEventListener('mouseup', (e)=>{
  const rect = canvas.getBoundingClientRect();
  if(!cropStart){ cropEnd=null; return; }
  cropEnd = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  render();
});

/* ========= OCR ========= */
const ocrText = document.getElementById('ocrText');
let tessWorker=null;

async function ensureWorker(){
  if(!tessWorker){
    msg('Inițializez OCR…','wait');
    tessWorker = await Tesseract.createWorker('ron+eng'); // română + engleză
  }
}

function getCropImageData(){
  if(!imgBitmap) return null;
  if(!cropStart || !cropEnd){
    // tot canvasul
    return canvas.transferToImageBitmap ? canvas.transferToImageBitmap() : null;
  }
  const x = Math.max(0, Math.min(cropStart.x, cropEnd.x));
  const y = Math.max(0, Math.min(cropStart.y, cropEnd.y));
  const w = Math.min(canvas.width - x, Math.abs(cropStart.x - cropEnd.x));
  const h = Math.min(canvas.height - y, Math.abs(cropStart.y - cropEnd.y));
  if (w<10 || h<10) return null;

  const tmp = document.createElement('canvas');
  tmp.width = w; tmp.height = h;
  const tctx = tmp.getContext('2d');
  tctx.drawImage(canvas, x, y, w, h, 0, 0, w, h);
  return tmp;
}

async function doOCR(sourceCanvas){
  await ensureWorker();
  msg('Rulez OCR…','wait');
  const { data:{ text } } = await tessWorker.recognize(sourceCanvas);
  const clean = normalizeOCR(text);
  ocrText.value = clean;
  msg('OCR terminat. Apasă „Extrage câmpuri”.','ok');
  log('OCR complet. '+Math.max(10,clean.length)+' caractere','ok');
}

/* Normalizez OCR: unesc linii rupte, repar ligaturi, diacritice comune */
function normalizeOCR(t){
  if(!t) return '';
  let s = t.replace(/\r/g,'');
  // scoate header/footer repetitiv
  s = s.replace(/[—–-]\s*Descrierea\s+CIP[^\n]*\n/gi,'\n');
  // uneste cuvinte rupte la capăt de linie: "infor-\nmație" -> "informație"
  s = s.replace(/-\n/g,'');
  // spații multiple -> un spațiu
  s = s.replace(/[ \t]+\n/g,'\n').replace(/\n{3,}/g,'\n\n');
  s = s.replace(/[ \t]{2,}/g,' ');
  // corecții frecvente OCR
  s = s.replace(/I S B N/gi,'ISBN').replace(/I S S N/gi,'ISSN');
  s = s.replace(/Bucureşti/g,'București');
  return s.trim();
}

ocrBtn.addEventListener('click', async ()=>{
  if(!imgBitmap){ msg('Încarcă o imagine sau fă o poză întâi.','err'); return; }
  await doOCR(canvas);
});
ocrCropBtn.addEventListener('click', async ()=>{
  if(!imgBitmap){ msg('Încarcă o imagine sau fă o poză întâi.','err'); return; }
  const crop = getCropImageData(); if(!crop){ msg('Selectează cu mouse-ul zona CIP (trage un dreptunghi).','err'); return; }
  await doOCR(crop);
});

/* ========= Parsare CIP → câmpuri ========= */
const outType = document.getElementById('outType');
const outTitle= document.getElementById('outTitle');
const outAuthors=document.getElementById('outAuthors');
const outPublisher=document.getElementById('outPublisher');
const outYear=document.getElementById('outYear');
const outISBN=document.getElementById('outISBN');
const outISSN=document.getElementById('outISSN');
const parseBtn=document.getElementById('parseBtn');
const clearTextBtn=document.getElementById('clearTextBtn');
const saveBtn=document.getElementById('saveBtn');
const discardBtn=document.getElementById('discardBtn');

function enableSave(on){ saveBtn.disabled=!on; discardBtn.disabled=!on; }

function cleanIsbn(raw){
  if(!raw) return '';
  let s = raw.replace(/[^0-9Xx]/g,'').toUpperCase();
  // dacă sunt 10 cifre -> ISBN10, dacă 13 -> ISBN13
  if(s.length===10 || s.length===13) return s;
  // uneori OCR ratează un X sau o cifră; nu forțăm
  return s;
}
function cleanIssn(raw){
  if(!raw) return '';
  let s = raw.replace(/[^0-9Xx]/g,'').toUpperCase();
  if(s.length===8){ return s.slice(0,4)+'-'+s.slice(4); }
  return s;
}

function parseCIP(text){
  const src = (text||'').trim();
  const lower = src.toLowerCase();

  // ISBN
  let isbnMatch = src.match(/ISBN(?:\s*13)?\s*[:]?\s*([0-9Xx][0-9\-\sXx]{7,})/);
  if(!isbnMatch){ // alte variante
    isbnMatch = src.match(/\b(97[89][0-9\-\s]{8,}[0-9Xx])\b/);
  }
  const isbn = cleanIsbn(isbnMatch?.[1]||'');

  // ISSN (uneori apare în CIP pentru serii)
  let issnMatch = src.match(/ISSN\s*[:]?\s*([0-9Xx][0-9\-\sXx]{3,})/i);
  const issn = cleanIssn(issnMatch?.[1]||'');

  // Titlu + Autori (heurstică: linia înainte de "/" e titlu; după "/" autorii)
  // Luăm primele 6-10 linii semnificative (după „Descrierea CIP...”)
  let block = src;
  const idxCIP = lower.indexOf('descrierea cip');
  if(idxCIP>=0) block = src.slice(idxCIP).split('\n').slice(0,12).join('\n');

  // Încercare 1: pattern „Titlu / Autori.”
  let title='', authors='';
  const m1 = block.match(/^\s*([^\n\/]{4,})\s*\/\s*([^\n\.]{3,})/m);
  if(m1){ title = m1[1].trim().replace(/\s{2,}/g,' '); authors = m1[2].trim(); }

  // Încercare 2: „Autor: …” sau „de …”
  if(!authors){
    const mAu = block.match(/\b(Autor(?:i)?|de)\s*[:]*\s*([^\n\.]{3,})/i);
    if(mAu) authors = mAu[2].trim();
  }
  // Dacă încă nu avem titlu, caută prima linie mai lungă fără doi-coloni sau cifre multe
  if(!title){
    const lines = block.split('\n').map(s=>s.trim()).filter(s=>s && s.length>4);
    title = (lines[0]||'').replace(/\s{2,}/g,' ');
    // curăță trailing „:” dacă e header
    title = title.replace(/[:\.\-–—]\s*$/,'');
  }
  // curățări autori
  authors = authors.replace(/\s{2,}/g,' ').replace(/\s*;\s*/g,', ').replace(/\s*,\s*,/g,', ').trim();
  authors = authors.replace(/\b(coord\.?|editori?|eds?\.)\b/gi,'').replace(/\s{2,}/g,' ').trim();

  // Editura + An: tipar frecvent „Localitate : Editura X, 2023.”
  let publisher='', year='';
  const placePub = block.match(/:\s*([^,\n]{2,}?)\s*,\s*(\d{4})/);
  if(placePub){ publisher = placePub[1].trim(); year = placePub[2]; }
  // „Editura …, 2021”
  if(!publisher){
    const mEd = block.match(/Editura\s+([^\.,\n]{2,})/i);
    if(mEd) publisher = mEd[1].trim();
  }
  if(!year){
    const years = src.match(/\b(19|20)\d{2}\b/g);
    if(years) year = years[0];
  }

  let type = isbn ? 'isbn' : (issn ? 'issn' : '');
  return { type, title, authors, publisher, year, isbn, issn };
}

parseBtn.addEventListener('click', ()=>{
  const t = ocrText.value;
  if(!t){ msg('Nu există text pentru parsare. Rulează OCR sau lipește text.','err'); return; }
  const r = parseCIP(t);
  outType.value = r.type || '';
  outTitle.value = r.title || '';
  outAuthors.value = r.authors || '';
  outPublisher.value = r.publisher || '';
  outYear.value = r.year || '';
  outISBN.value = r.isbn || '';
  outISSN.value = r.issn || '';
  enableSave(true);
  msg('Extragere completă. Verifică și salvează.','ok');

  if(cbAutoSave.checked){
    doSave();
  }
});

clearTextBtn.addEventListener('click', ()=>{ ocrText.value=''; msg('Text golit.',''); });

discardBtn.addEventListener('click', ()=>{
  outType.value=''; outTitle.value=''; outAuthors.value=''; outPublisher.value=''; outYear.value=''; outISBN.value=''; outISSN.value='';
  enableSave(false);
  msg('Intrare ignorată.','');
});

async function doSave(){
  const pl = {
    op: 'save',
    mode: 'cip',
    type: (outType.value||'').toLowerCase(),
    title: outTitle.value||'',
    authors: outAuthors.value||'',
    publisher: outPublisher.value||'',
    year: outYear.value||'',
    isbn: outISBN.value||'',
    issn: outISSN.value||'',
    raw: ocrText.value||''
  };
  const resp = await postToSheet(pl);
  if (resp.ok){ msg('✔ Salvat în foaie.','ok'); log(`✔ Salvat: ${pl.title || pl.isbn || pl.issn}`,'ok'); enableSave(false); }
  else { msg('✖ Eroare la salvare: '+(resp.info||'(unknown)'),'err'); log('✖ '+(resp.info||'(unknown)'),'err'); }
}
saveBtn.addEventListener('click', doSave);

/* ========= Inițializare ========= */
if (!secureOk()) msg('Atenție: pentru cameră folosește HTTPS sau rulează local pe localhost.','err');
</script>
</body>
</html>
