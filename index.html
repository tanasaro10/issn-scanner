<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ISBN/ISSN + CIP (OCR cu selecție) → Google Sheet</title>
  <style>
    :root { --ok:#12a150; --warn:#b00020; --muted:#666; --card:#fff; --line:#e6e6e6; --bg:#fafafa; }
    body { font-family: system-ui, Arial, sans-serif; margin:0; padding:14px; background:var(--bg); color:#111; }
    h2 { margin:0; }
    .top { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .badge { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; font-weight:600; border:1px solid var(--line); background:#f4fdf7; color:#12a150; }
    .badge.bad { background:#fff4f4; color:#b00020; }
    .card { background:var(--card); border:1px solid var(--line); border-radius:12px; padding:14px; margin-top:14px; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .grid { display:grid; gap:10px; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); }
    button { padding:10px 14px; border-radius:10px; border:1px solid #ccc; background:#f6f6f6; cursor:pointer; }
    button:disabled { opacity:.6; cursor:not-allowed; }
    input[type=text], input[type=password], textarea { padding:8px; border-radius:8px; border:1px solid #ccc; width:100%; }
    label { font-size:13px; color:#333; }
    .muted { color:var(--muted); font-size:12px; margin-top:6px; }
    .status { padding:10px; border-radius:10px; border:1px dashed var(--line); background:#fff; font-size:14px; }
    .status.wait { background:#fffdf3; border-color:#e8d28b; }
    .status.ok   { background:#f4fdf7; border-color:#cce9d7; }
    .status.err  { background:#fff4f4; border-color:#f0b6b6; }
    .status.warn { background:#fffdf3; border-color:#e8d28b; }
    .log { font-family: ui-monospace, SFMono-Regular, Consolas, monospace; white-space:pre-wrap; font-size:12px; }
    .ok { color:#12a150; } .err { color:#b00020; }
    .camera-shell { overflow:hidden; transition:max-height .25s ease, padding .25s ease, border-width .25s ease; max-height:0; padding:0 0; border:0 solid var(--line); border-radius:12px; background:#000; }
    .camera-shell.active { max-height:70vh; padding:10px; border-width:1px; }
    video, canvas { width:100%; border-radius:8px; background:#000; display:block; }
    .stage { position:relative; }
    .hint { color:#fff; position:absolute; right:8px; bottom:8px; background:rgba(0,0,0,.5); padding:4px 8px; border-radius:8px; font-size:12px; }
    .result-form { display:grid; gap:10px; grid-template-columns:repeat(auto-fit,minmax(220px,1fr)); }
    .field { display:flex; flex-direction:column; gap:6px; }
    .actions { display:flex; gap:10px; margin-top:8px; flex-wrap:wrap; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <div class="top">
    <h2>Scanează: EAN-13 (ISBN/ISSN) sau CIP (OCR) → Google Sheet</h2>
    <span id="cfgBadge" class="badge bad">Config lipsă</span>
  </div>

  <details class="card" open>
    <summary>Config (Script ID & Secret)</summary>
    <div class="grid">
      <div>
        <label>Google Script ID</label>
        <input id="scriptId" type="text" placeholder="AKfycbx..." />
        <div class="muted">Webhook: <code>https://script.google.com/macros/s/&lt;ID&gt;/exec</code></div>
      </div>
      <div>
        <label>Secret (Token)</label>
        <input id="secret" type="password" placeholder="••••••" />
      </div>
      <div>
        <label>Device ID (opțional)</label>
        <input id="deviceId" type="text" placeholder="ex. phone01" />
      </div>
      <div class="row" style="align-items:flex-end">
        <button id="saveCfgBtn" type="button">Salvează</button>
        <button id="clearCfgBtn" type="button">Șterge</button>
      </div>
    </div>
  </details>

  <div class="card">
    <div class="row">
      <button id="startBtn" type="button">Pornește camera</button>
      <button id="stopBtn" type="button" disabled>Oprește camera</button>
    </div>
    <div id="cameraShell" class="camera-shell">
      <video id="preview" playsinline muted title="Atinge pentru a îngheța cadrul și a selecta zona CIP"></video>
      <div class="stage" style="display:none" id="stage">
        <canvas id="cropCanvas"></canvas>
        <div class="hint" id="cropHint" style="display:none">Selectează zona CIP cu degetul/mouse-ul</div>
      </div>
      <canvas id="snapCanvas" style="display:none"></canvas>
    </div>
    <div class="row">
      <input id="imgFile" type="file" accept="image/*,.png,.jpg,.jpeg,.webp,.bmp,.tif,.tiff" />
      <button id="ocrFromFileBtn" type="button" disabled>OCR din fișier</button>
      <button id="ocrCropBtn" type="button" disabled>OCR pe selecție</button>
    </div>
    <div class="muted">
      • Camera detectează automat EAN-13. La ISBN, camera se oprește.<br>
      • Dacă nu detectează nimic, atinge video-ul pentru a îngheța cadrul și a decupa zona CIP.
    </div>
  </div>

  <div class="card">
    <div><strong>Text OCR (opțional – poți lipi aici)</strong></div>
    <textarea id="ocrText" rows="6" placeholder="Aici apare textul rezultat din OCR…"></textarea>
    <div class="actions">
      <button id="parseBtn" type="button">Extrage câmpuri din text</button>
      <button id="clearTextBtn" type="button">Golește</button>
    </div>
  </div>

  <div class="card">
    <div id="statusBox" class="status">Gata.</div>
    <div style="margin-top:8px">
      <div><strong>Rezultat (editabil înainte de salvare)</strong></div>
      <div class="result-form" style="margin-top:8px">
        <div class="field"><label>Tip</label><input id="outType" type="text" placeholder="isbn/issn/cip" /></div>
        <div class="field"><label>Titlu</label><input id="outTitle" type="text" /></div>
        <div class="field"><label>Autori</label><input id="outAuthors" type="text" placeholder="nume, prenume; ..." /></div>
        <div class="field"><label>Editura</label><input id="outPublisher" type="text" /></div>
        <div class="field"><label>An</label><input id="outYear" type="text" /></div>
        <div class="field"><label>ISBN</label><input id="outISBN" type="text" /></div>
        <div class="field"><label>ISSN</label><input id="outISSN" type="text" /></div>
        <div class="field" style="grid-column:1/-1"><label>Text CIP (raw)</label><textarea id="outRaw" rows="4" placeholder="textul integral OCR"></textarea></div>
      </div>
      <div class="actions">
        <button id="saveBtn" type="button" disabled>Salvează</button>
        <button id="discardBtn" type="button" disabled>Nu salva</button>
      </div>
    </div>
  </div>

  <div class="card">
    <div><strong>Jurnal</strong></div>
    <div id="last" class="log"></div>
  </div>

<script>
/* ============ Config minimal ============ */
const BASE_WEBAPP = "https://script.google.com/macros/s/";
const badge       = document.getElementById('cfgBadge');
const scriptIdEl  = document.getElementById('scriptId');
const secretEl    = document.getElementById('secret');
const deviceEl    = document.getElementById('deviceId');
const statusBox   = document.getElementById('statusBox');

function setBadge(ok){
  if(ok){
    badge.textContent='Config OK';
    badge.classList.remove('bad');
  } else {
    badge.textContent='Config lipsă';
    badge.classList.add('bad');
  }
}
function getCfg(){
  return {
    scriptId: localStorage.getItem('scanner_script_id') || '',
    secret:   localStorage.getItem('scanner_secret')    || '',
    device:   localStorage.getItem('scanner_device')    || ''
  };
}
function saveCfg({scriptId, secret, device}){
  if (typeof scriptId === 'string') localStorage.setItem('scanner_script_id', scriptId.trim());
  if (typeof secret   === 'string') localStorage.setItem('scanner_secret',    secret.trim());
  if (typeof device   === 'string') localStorage.setItem('scanner_device',    device.trim());
  fillInputsFromStorage();
  msg('Config salvată local.','ok');
}
function clearCfg(){
  localStorage.removeItem('scanner_script_id');
  localStorage.removeItem('scanner_secret');
  localStorage.removeItem('scanner_device');
  scriptIdEl.value=''; secretEl.value=''; deviceEl.value='';
  setBadge(false);
  msg('Config ștearsă.','');
}
function fillInputsFromStorage(){
  const {scriptId, secret, device} = getCfg();
  scriptIdEl.value=scriptId;
  secretEl.value=secret;
  deviceEl.value=device;
  setBadge(Boolean(scriptId && secret));
}
fillInputsFromStorage();

document.getElementById('saveCfgBtn').addEventListener('click', ()=>{
  saveCfg({scriptId:scriptIdEl.value, secret:secretEl.value, device:deviceEl.value});
});
document.getElementById('clearCfgBtn').addEventListener('click', clearCfg);

function msg(text, type=''){
  statusBox.className='status ' + (type||'');
  statusBox.textContent=text;
}
function log(text, cls=''){
  const last=document.getElementById('last');
  last.innerHTML = `<div class="${cls}">${new Date().toLocaleTimeString()} — ${text}</div>` + last.innerHTML;
}
const secureOk = () => (window.isSecureContext || location.protocol==='https:' || location.hostname==='localhost');
function buildWebhook(){
  const {scriptId}=getCfg();
  return scriptId ? (BASE_WEBAPP + scriptId + "/exec") : '';
}

async function postToSheet(payload){
  const {secret, device} = getCfg(); const webhook = buildWebhook();
  if (!webhook || !secret) return { ok:false, info:'Config incompletă (Script ID/Secret).' };
  try {
    const r = await fetch(webhook, {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ token:secret, deviceId: device||'', ...payload })
    });
    const j = await r.json().catch(()=> ({}));
    return { ok: !!j.ok, info: j.error || '' };
  } catch (e1) {
    try {
      const form = new URLSearchParams();
      form.set('token', secret);
      form.set('deviceId', device||'');
      Object.entries(payload).forEach(([k,v])=> form.set(k, Array.isArray(v)? v.join(', ') : (v==null?'':String(v))));
      const r2 = await fetch(webhook, {
        method:'POST',
        headers:{'Content-Type':'application/x-www-form-urlencoded'},
        body: form.toString()
      });
      const j2 = await r2.json().catch(()=> ({}));
      return { ok: (j2.ok===true)||r2.ok, info: j2.error || '' };
    } catch (e2) {
      try {
        const form = new URLSearchParams();
        form.set('token', secret);
        form.set('deviceId', device||'');
        Object.entries(payload).forEach(([k,v])=> form.set(k, Array.isArray(v)? v.join(', ') : (v==null?'':String(v))));
        await fetch(webhook, {
          method:'POST',
          mode:'no-cors',
            headers:{'Content-Type':'application/x-www-form-urlencoded'},
          body: form.toString()
        });
        return { ok:true, info:'sent-no-cors' };
      } catch (e3) {
        return { ok:false, info:String(e3) };
      }
    }
  }
}

/* ============ Cameră + BarcodeDetector ============ */
const preview = document.getElementById('preview');
const startBtn = document.getElementById('startBtn');
const stopBtn  = document.getElementById('stopBtn');
const cameraShell  = document.getElementById('cameraShell');
const snapCanvas = document.getElementById('snapCanvas');

let stream=null, detector=null, scanning=false;
let lastEan=null, lastAt=0;

async function ensureBarcodeDetector(){
  if (!('BarcodeDetector' in window)) return false;
  try{
    const f = await window.BarcodeDetector.getSupportedFormats();
    return f.includes('ean_13') || f.includes('ean13');
  }catch{
    return false;
  }
}
async function startCamera(){
  if (!secureOk()) { msg('Deschide pe HTTPS sau localhost pentru acces cameră.', 'err'); return; }
  try{
    stream = await navigator.mediaDevices.getUserMedia({ video:{facingMode:{ideal:'environment'}}, audio:false });
    preview.srcObject=stream; await preview.play();
    cameraShell.classList.add('active');
    startBtn.disabled=true; stopBtn.disabled=false;
    const ok = await ensureBarcodeDetector();
    if (!ok) { msg('Browserul nu suportă BarcodeDetector (EAN-13). Poți folosi doar OCR.', 'err'); return; }
    detector = new window.BarcodeDetector({ formats:['ean_13'] });
    scanning = true; msg('Scanez EAN-13… Tap pe video ca să îngheți cadrul dacă nu găsește.', '');
    requestAnimationFrame(scanLoop);
  }catch(e){ msg('Eroare pornire cameră: '+(e.message||e.name), 'err'); }
}
function stopCamera(collapse=true){
  try{ stream?.getTracks?.().forEach(t=>t.stop()); }catch{}
  stream=null; preview.srcObject=null; scanning=false;
  stopBtn.disabled=true; startBtn.disabled=false;
  if(collapse) cameraShell.classList.remove('active');
}

startBtn.addEventListener('click', ()=>{
  preview.style.display = 'block';
  try { preview.play(); } catch(e){}
  stage.style.display = 'none';
  cropHint.style.display = 'none';
  scanning = false;
  startCamera();
});
stopBtn.addEventListener('click', ()=>{ scanning=false; stopCamera(); msg('Camera oprită.', ''); });

preview.addEventListener('click', async ()=>{
  if (!preview.videoWidth) return;
  const cw = preview.videoWidth, ch = preview.videoHeight;
  snapCanvas.width = cw; snapCanvas.height = ch;
  snapCanvas.getContext('2d').drawImage(preview, 0, 0, cw, ch);
  const bmp = await createImageBitmap(snapCanvas);
  scanning = false;
  try { preview.pause(); } catch(e){}
  preview.style.display = 'none';
  drawImageToCropCanvas(bmp);
  stage.style.display = 'block';
  cropHint.style.display = 'block';
  msg('Cadrul a fost înghețat. Selectează zona CIP și apasă „OCR pe selecție”.','ok');
});

function classifyPublication(ean13){
  if(!/^\d{13}$/.test(ean13)) return {type:'other'};
  if(ean13.startsWith('977')) return {type:'issn'};
  if(ean13.startsWith('978')||ean13.startsWith('979')) return {type:'isbn'};
  return {type:'other'};
}

async function scanLoop(){
  if (!detector || !scanning) return;
  try{
    const barcodes = await detector.detect(preview);
    if (barcodes && barcodes.length){
      for (const b of barcodes){
        const raw = String(b.rawValue||'').trim(); if (!raw) continue;
        const now=Date.now(); if (raw===lastEan && (now-lastAt)<2000) continue;
        lastEan=raw; lastAt=now;
        const cls = classifyPublication(raw);
        if (cls.type==='isbn'){
          scanning = false;
          stopCamera(false); // Stop camera but keep container visible
          await fetchAndFillMetadata({ isbn: raw });
          return;
        } else if (cls.type==='issn'){
          scanning = false;
          stopCamera(false); // Stop camera but keep container visible
          await fetchAndFillMetadata({ issn: raw });
          return;
        }
      }
    }
  }catch(e){ /* ignore */ }
  finally { if (scanning) requestAnimationFrame(scanLoop); }
}

/* ============ OCR cu selecție + parsare ============ */
const imgFile    = document.getElementById('imgFile');
const ocrFromFileBtn = document.getElementById('ocrFromFileBtn');
const ocrCropBtn = document.getElementById('ocrCropBtn');
const ocrText    = document.getElementById('ocrText');
const parseBtn   = document.getElementById('parseBtn');
const clearTextBtn = document.getElementById('clearTextBtn');
const saveBtn    = document.getElementById('saveBtn');
const discardBtn = document.getElementById('discardBtn');

const cropCanvas = document.getElementById('cropCanvas');
const cropCtx = cropCanvas.getContext('2d');
const stage = document.getElementById('stage');
const cropHint = document.getElementById('cropHint');

let tessWorker=null;
let lastImageBitmap = null;
let cropStart = null;
let cropEnd = null;

async function ensureWorker(){
  if(!tessWorker){
    msg('Inițializez OCR…','wait');
    tessWorker = await Tesseract.createWorker('ron+eng');
  }
}
function normalizeOCR(t){
  if(!t) return '';
  let s=t.replace(/\r/g,'');
  s=s.replace(/-\n/g,'');
  s=s.replace(/[ \t]+\n/g,'\n');
  s=s.replace(/\n{3,}/g,'\n\n');
  s=s.replace(/[ \t]{2,}/g,' ');
  return s.trim();
}
function cleanIsbn(raw){
  if(!raw) return ''; let s=raw.replace(/[^0-9Xx]/g,'').toUpperCase();
  return s;
}
function cleanIssn(raw){
  if(!raw) return ''; let s=raw.replace(/[^0-9Xx]/g,'').toUpperCase();
  if(s.length===8) return s.slice(0,4)+'-'+s.slice(4);
  return s;
}
function parseCIP(text){
  const src=(text||'').trim(), lower=src.toLowerCase();
  let isbnMatch=src.match(/ISBN(?:\s*13)?\s*[:]?\s*([0-9Xx][0-9\-\sXx]{7,})/);
  if(!isbnMatch){ isbnMatch=src.match(/\b(97[89][0-9\-\s]{8,}[0-9Xx])\b/); }
  const isbn=cleanIsbn(isbnMatch?.[1]||'');
  let issnMatch=src.match(/ISSN\s*[:]?\s*([0-9Xx][0-9\-\sXx]{3,})/i);
  const issn=cleanIssn(issnMatch?.[1]||'');
  let block=src; const idxCIP=lower.indexOf('descrierea cip');
  if(idxCIP>=0) block=src.slice(idxCIP).split('\n').slice(0,12).join('\n');
  let title='', authors='';
  const m1=block.match(/^\s*([^\n\/]{4,})\s*\/\s*([^\n\.]{3,})/m);
  if(m1){ title=m1[1].trim().replace(/\s{2,}/g,' '); authors=m1[2].trim(); }
  if(!authors){
    const mAu=block.match(/\b(Autor(?:i)?|de)\s*[:]?\s*([^\n\.]{3,})/i);
    if(mAu) authors=mAu[2].trim();
  }
  if(!title){
    const lines=block.split('\n').map(s=>s.trim()).filter(s=>s&&s.length>4);
    title=(lines[0]||'').replace(/\s{2,}/g,' ').replace(/[:\.\-–—]\s*$/,'');
  }
  authors=authors.replace(/\s{2,}/g,' ').replace(/\s*;\s*/g,', ').replace(/\s*,\s*,/g,', ')
    .replace(/\b(coord\.?|editori?|eds?\.)\b/gi,'').trim();
  let publisher='', year='';
  const placePub=block.match(/:\s*([^,\n]{2,}?)\s*,\s*(\d{4})/);
  if(placePub){ publisher=placePub[1].trim(); year=placePub[2]; }
  if(!publisher){
    const mEd=block.match(/Editura\s+([^\.,\n]{2,})/i);
    if(mEd) publisher=mEd[1].trim();
  }
  if(!year){
    const years=src.match(/\b(19|20)\d{2}\b/g);
    if(years) year=years[0];
  }
  let type = isbn ? 'isbn' : (issn ? 'issn' : 'cip');
  return { type, title, authors, publisher, year, isbn, issn, raw: src };
}

/* ============ Metadata Lookup ============ */
async function fetchJSON(url, timeoutMs = 6000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  
  try {
    const response = await fetch(url, { 
      signal: controller.signal,
      headers: { 'User-Agent': 'ISSN-Scanner/1.0' }
    });
    clearTimeout(timeoutId);
    
    if (!response.ok) {
      return null;
    }
    
    return await response.json();
  } catch (error) {
    clearTimeout(timeoutId);
    console.warn('Fetch error:', error);
    return null;
  }
}

function normalizeYear(y) {
  if (!y) return '';
  const str = String(y);
  const match = str.match(/\b(19|20)\d{2}\b/);
  return match ? match[0] : '';
}

async function lookupISBN(isbn) {
  if (!isbn) return null;
  
  try {
    // Try OpenLibrary first
    const olUrl = `https://openlibrary.org/isbn/${isbn}.json`;
    const olData = await fetchJSON(olUrl);
    
    if (olData && olData.title) {
      const result = {
        title: olData.title || '',
        authors: '',
        publisher: '',
        year: ''
      };
      
      // Extract authors
      if (olData.authors && olData.authors.length > 0) {
        const authorPromises = olData.authors.slice(0, 3).map(async (author) => {
          if (author.key) {
            const authorData = await fetchJSON(`https://openlibrary.org${author.key}.json`);
            return authorData?.name || '';
          }
          return '';
        });
        const authorNames = await Promise.all(authorPromises);
        result.authors = authorNames.filter(name => name).join(', ');
      }
      
      // Extract publisher and year
      if (olData.publishers && olData.publishers.length > 0) {
        result.publisher = olData.publishers[0];
      }
      
      if (olData.publish_date) {
        result.year = normalizeYear(olData.publish_date);
      }
      
      // If we have basic info, return it (might fill missing fields from Google Books)
      if (result.title) {
        return result;
      }
    }
    
    // Fallback to Google Books API
    const gbUrl = `https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`;
    const gbData = await fetchJSON(gbUrl);
    
    if (gbData && gbData.items && gbData.items.length > 0) {
      const book = gbData.items[0].volumeInfo;
      return {
        title: book.title || '',
        authors: book.authors ? book.authors.join(', ') : '',
        publisher: book.publisher || '',
        year: normalizeYear(book.publishedDate)
      };
    }
    
  } catch (error) {
    console.warn('ISBN lookup error:', error);
  }
  
  return null;
}

async function lookupISSN(issn) {
  if (!issn) return null;
  
  try {
    // Try CrossRef Journal API first
    const journalUrl = `https://api.crossref.org/journals/${issn}`;
    const journalData = await fetchJSON(journalUrl);
    
    if (journalData && journalData.message && journalData.message.title) {
      return {
        title: journalData.message.title,
        authors: '', // Journals typically don't have authors
        publisher: journalData.message.publisher || '',
        year: ''
      };
    }
    
    // Fallback to CrossRef Works API for recent publications
    const worksUrl = `https://api.crossref.org/works?sort=published&order=desc&rows=1&filter=issn:${issn}`;
    const worksData = await fetchJSON(worksUrl);
    
    if (worksData && worksData.message && worksData.message.items && worksData.message.items.length > 0) {
      const work = worksData.message.items[0];
      return {
        title: work['container-title'] && work['container-title'][0] ? work['container-title'][0] : '',
        authors: '',
        publisher: work.publisher || '',
        year: work.published ? normalizeYear(work.published['date-parts'][0][0]) : ''
      };
    }
    
  } catch (error) {
    console.warn('ISSN lookup error:', error);
  }
  
  return null;
}

async function fetchAndFillMetadata({ isbn, issn }) {
  const isIsbn = !!isbn;
  const code = isbn || issn;
  const type = isIsbn ? 'ISBN' : 'ISSN';
  
  if (!code) return;
  
  // Show searching message
  msg(`Caut metadate pentru ${type} ${code}...`, 'wait');
  
  try {
    const metadata = isIsbn ? await lookupISBN(isbn) : await lookupISSN(issn);
    
    if (metadata && metadata.title) {
      // Found metadata - populate form
      const formData = {
        type: isIsbn ? 'isbn' : 'issn',
        title: metadata.title,
        authors: metadata.authors,
        publisher: metadata.publisher,
        year: metadata.year,
        isbn: isbn || '',
        issn: issn || ''
      };
      
      populateForm(formData);
      msg(`Metadate ${type} găsite. Verifică și salvează.`, 'ok');
    } else {
      // No metadata found - populate minimal form and suggest OCR
      const formData = {
        type: isIsbn ? 'isbn' : 'issn',
        isbn: isbn || '',
        issn: issn || ''
      };
      
      populateForm(formData);
      msg(`Nu am găsit metadate pentru acest ${type}. Folosește OCR.`, 'warn');
    }
  } catch (error) {
    console.error('Metadata fetch error:', error);
    
    // Error case - populate minimal form
    const formData = {
      type: isIsbn ? 'isbn' : 'issn',
      isbn: isbn || '',
      issn: issn || ''
    };
    
    populateForm(formData);
    msg('Eroare la căutarea metadatelor. Poți folosi OCR.', 'err');
  }
}

/* randare & selecție */
function drawImageToCropCanvas(imgBitmap){
  lastImageBitmap=imgBitmap;
  const maxW=1600, scale=Math.min(1, maxW/imgBitmap.width);
  cropCanvas.width=Math.round(imgBitmap.width*scale);
  cropCanvas.height=Math.round(imgBitmap.height*scale);
  cropCtx.clearRect(0,0,cropCanvas.width,cropCanvas.height);
  cropCtx.drawImage(imgBitmap,0,0,cropCanvas.width,cropCanvas.height);
  stage.style.display='block'; cropHint.style.display='block'; ocrCropBtn.disabled=false;
  cropStart=cropEnd=null;
}
function redrawWithSelection(){
  if(!lastImageBitmap) return;
  cropCtx.drawImage(lastImageBitmap,0,0,cropCanvas.width,cropCanvas.height);
  if(cropStart && cropEnd){
    const x=Math.min(cropStart.x,cropEnd.x), y=Math.min(cropStart.y,cropEnd.y);
    const w=Math.abs(cropStart.x-cropEnd.x), h=Math.abs(cropStart.y-cropEnd.y);
    cropCtx.save();
    cropCtx.strokeStyle='#00ff99';
    cropCtx.lineWidth=2;
    cropCtx.setLineDash([6,4]);
    cropCtx.strokeRect(x+.5,y+.5,w,h);
    cropCtx.restore();
  }
}
function getCropCanvas(){
  if(!cropStart||!cropEnd) return null;
  const x=Math.max(0,Math.min(cropStart.x,cropEnd.x));
  const y=Math.max(0,Math.min(cropStart.y,cropEnd.y));
  const w=Math.min(cropCanvas.width-x,Math.abs(cropStart.x-cropEnd.x));
  const h=Math.min(cropCanvas.height-y,Math.abs(cropStart.y-cropEnd.y));
  if(w<10||h<10) return null;
  const out=document.createElement('canvas'); out.width=w; out.height=h;
  out.getContext('2d').drawImage(cropCanvas,x,y,w,h,0,0,w,h);
  return out;
}
function canvasPosFromEvent(e){
  const rect=cropCanvas.getBoundingClientRect();
  const sx=cropCanvas.width/rect.width, sy=cropCanvas.height/rect.height;
  if(e.touches&&e.touches[0]) return { x:(e.touches[0].clientX-rect.left)*sx, y:(e.touches[0].clientY-rect.top)*sy };
  return { x:(e.clientX-rect.left)*sx, y:(e.clientY-rect.top)*sy };
}
cropCanvas.addEventListener('mousedown',e=>{ cropStart=canvasPosFromEvent(e); cropEnd=null; redrawWithSelection(); });
cropCanvas.addEventListener('mousemove',e=>{ if(!cropStart) return; cropEnd=canvasPosFromEvent(e); redrawWithSelection(); });
cropCanvas.addEventListener('mouseup',e=>{ if(!cropStart) return; cropEnd=canvasPosFromEvent(e); redrawWithSelection(); });
cropCanvas.addEventListener('touchstart',e=>{ e.preventDefault(); cropStart=canvasPosFromEvent(e); cropEnd=null; redrawWithSelection(); },{passive:false});
cropCanvas.addEventListener('touchmove',e=>{ e.preventDefault(); if(!cropStart) return; cropEnd=canvasPosFromEvent(e); redrawWithSelection(); },{passive:false});
cropCanvas.addEventListener('touchend',e=>{ e.preventDefault(); redrawWithSelection(); },{passive:false});

/* OCR pe selecție / fișier */
async function ensureWorkerAndRecognize(srcCanvasOrImage){
  await ensureWorker(); msg('Rulez OCR…','wait');
  const { data:{ text } } = await tessWorker.recognize(srcCanvasOrImage);
  const clean=normalizeOCR(text); ocrText.value=clean;
  msg('OCR terminat. „Extrage câmpuri din text”.','ok');
  return clean;
}
ocrCropBtn.addEventListener('click', async ()=>{
  const sel=getCropCanvas(); if(!sel){ msg('Selectează zona CIP pentru OCR.','err'); return; }
  const clean=await ensureWorkerAndRecognize(sel);
  const r=parseCIP(clean); populateForm(r); msg('Extragere din OCR. Poți corecta și salva.','ok');
});
imgFile.addEventListener('change',()=>{ ocrFromFileBtn.disabled=!imgFile.files?.[0]; });
ocrFromFileBtn.addEventListener('click', async ()=>{
  const f=imgFile.files?.[0]; if(!f){ msg('Alege un fișier imagine.','err'); return; }
  const bmp=await createImageBitmap(f); drawImageToCropCanvas(bmp);
  msg('Imagine încărcată. Selectează zona CIP și apasă „OCR pe selecție”.','');
});

/* Formular + salvare */
function populateForm(pl){
  document.getElementById('outType').value = pl.type || '';
  document.getElementById('outTitle').value = pl.title || '';
  document.getElementById('outAuthors').value = pl.authors || '';
  document.getElementById('outPublisher').value = pl.publisher || '';
  document.getElementById('outYear').value = pl.year || '';
  document.getElementById('outISBN').value = pl.isbn || '';
  document.getElementById('outISSN').value = pl.issn || '';
  document.getElementById('outRaw').value = pl.raw || '';
  saveBtn.disabled=false;
  discardBtn.disabled=false;
}
parseBtn.addEventListener('click', ()=>{
  const t=ocrText.value; if(!t){ msg('Nu există text pentru parsare.','err'); return; }
  const r=parseCIP(t); populateForm(r); msg('Câmpuri extrase. Poți corecta și salva.','ok');
});
clearTextBtn.addEventListener('click', ()=>{ ocrText.value=''; msg('Text golit.',''); });

async function doSave(){
  const pl={
    op:'save', mode:'cip',
    type:(document.getElementById('outType').value||'').toLowerCase(),
    title:document.getElementById('outTitle').value||'',
    authors:document.getElementById('outAuthors').value||'',
    publisher:document.getElementById('outPublisher').value||'',
    year:document.getElementById('outYear').value||'',
    isbn:document.getElementById('outISBN').value||'',
    issn:document.getElementById('outISSN').value||'',
    raw:document.getElementById('outRaw').value||''
  };
  const resp=await postToSheet(pl);
  if(resp.ok){
    msg('✔ Salvat.', 'ok');
    log(`✔ Salvat: ${pl.title || pl.isbn || pl.issn}`,'ok');
    saveBtn.disabled=true;
    discardBtn.disabled=true;
  } else {
    msg('✖ Eroare la salvare: '+(resp.info||'(necunoscut)'),'err');
  }
  return resp;
}
saveBtn.addEventListener('click', doSave);
discardBtn.addEventListener('click', ()=>{
  ['outType','outTitle','outAuthors','outPublisher','outYear','outISBN','outISSN','outRaw']
    .forEach(id=> document.getElementById(id).value='');
  saveBtn.disabled=true;
  discardBtn.disabled=true;
  msg('Intrare ignorată.','');
});

/* Inițializări */
if (!secureOk()) msg('Atenție: folosește HTTPS/localhost pentru cameră.','err');
</script>
</body>
</html>
