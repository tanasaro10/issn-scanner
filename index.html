<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ISSN/ISBN Scanner → Google Sheet</title>
  <style>
    :root { --ok:#12a150; --warn:#b00020; --muted:#666; --card:#fff; --line:#e6e6e6; }
    body { font-family: system-ui, Arial, sans-serif; margin: 0; padding: 14px; background:#fafafa; }
    .top { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .badge {
      display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px;
      font-weight:600; border:1px solid var(--line); background:#f4fdf7; color:var(--ok);
    }
    .badge::before { content:""; width:8px; height:8px; border-radius:50%; background:var(--ok); display:inline-block; }
    .badge.bad { background:#fff4f4; color:var(--warn); }
    .badge.bad::before { background:var(--warn); }

    .card { background:var(--card); border:1px solid var(--line); border-radius: 12px; padding: 14px; margin-top: 14px; }
    .row { display:flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    video { width: 100%; border-radius: 12px; background: #000; }
    button { padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; background: #f6f6f6; }
    input[type=text], input[type=password] { padding: 8px; border-radius: 8px; border: 1px solid #ccc; width: 100%; }
    label { font-size: 14px; color: #444; }
    .muted { color:var(--muted); font-size:12px; margin-top:6px; }
    .log { font-family: ui-monospace, SFMono-Regular, Consolas, monospace; white-space: pre-wrap; }
    .ok { color: var(--ok); } .err { color: var(--warn); }

    details.config summary { cursor:pointer; font-weight:600; }
    details.config[open] summary { margin-bottom:8px; }
    .ghost { opacity:.6 }
  </style>
</head>
<body>
  <div class="top">
    <h2 style="margin:0">Scanează ISSN/ISBN → Google Sheet</h2>
    <span id="cfgBadge" class="badge bad">Config lipsă</span>
  </div>

  <!-- Camera + controale -->
  <div class="card">
    <div class="row">
      <button id="startBtn">Start cameră</button>
      <button id="stopBtn" disabled>Stop cameră</button>
      <button id="toggleTorchBtn" disabled>Torch</button>
    </div>
    <div style="margin-top:10px">
      <video id="preview" playsinline muted></video>
    </div>
    <div class="muted">Dacă nu pornește camera, asigură-te că pagina e pe HTTPS și ai permis accesul.</div>
  </div>

  <!-- Config (ascuns, pentru actualizări ulterioare) -->
  <details class="card config" id="cfgPanel">
    <summary>Config (opțional – pentru a actualiza Script ID & Secret)</summary>
    <div class="row">
      <div style="flex:1; min-width:260px">
        <label>Google Script ID</label>
        <input id="scriptId" type="text" placeholder="AKfycbx..." />
        <div class="muted ghost">Webhook-ul: <code>https://script.google.com/macros/s/&lt;ID&gt;/exec</code></div>
      </div>
      <div style="flex:1; min-width:220px">
        <label>Secret (Token)</label>
        <input id="secret" type="password" placeholder="••••••" />
      </div>
      <div style="display:flex; gap:8px; align-items:flex-end">
        <button id="saveCfgBtn" title="Salvează în browser (localStorage)">Salvează</button>
        <button id="clearCfgBtn" title="Șterge din browser">Șterge</button>
      </div>
    </div>
    <div class="row" style="margin-top:8px">
      <div style="flex:1; min-width:220px">
        <label>Device ID (opțional)</label>
        <input id="deviceId" type="text" placeholder="ex. phone01" />
      </div>
    </div>
    <div class="muted">Poți seta din URL o singură dată: <code>?SCRIPT_ID=&amp;SECRET=</code>. Valorile se salvează și sunt eliminate din URL.</div>
  </details>

  <div class="card">
    <div><strong>Ultima detecție</strong></div>
    <div id="last" class="log"></div>
  </div>

  <script>
    // ============== Config & Badge ==============
    const BASE_WEBAPP = "https://script.google.com/macros/s/";
    const badge = document.getElementById('cfgBadge');
    const scriptIdEl = document.getElementById('scriptId');
    const secretEl   = document.getElementById('secret');
    const deviceEl   = document.getElementById('deviceId');

    function setBadge(ok) {
      if (ok) { badge.textContent = 'Config OK'; badge.classList.remove('bad'); }
      else    { badge.textContent = 'Config lipsă'; badge.classList.add('bad'); }
    }
    function getCfg() {
      return {
        scriptId: localStorage.getItem('scanner_script_id') || '',
        secret:   localStorage.getItem('scanner_secret')    || '',
        device:   localStorage.getItem('scanner_device')    || ''
      };
    }
    function saveCfg({scriptId, secret, device}) {
      if (typeof scriptId === 'string') localStorage.setItem('scanner_script_id', scriptId.trim());
      if (typeof secret   === 'string') localStorage.setItem('scanner_secret',   secret.trim());
      if (typeof device   === 'string') localStorage.setItem('scanner_device',   device.trim());
      const cfg = getCfg();
      setBadge(Boolean(cfg.scriptId && cfg.secret));
    }
    function clearCfg() {
      localStorage.removeItem('scanner_script_id');
      localStorage.removeItem('scanner_secret');
      localStorage.removeItem('scanner_device');
      scriptIdEl.value=''; secretEl.value=''; deviceEl.value='';
      setBadge(false);
      log('Config ștearsă.', 'ok');
    }
    function fillInputsFromStorage() {
      const {scriptId, secret, device} = getCfg();
      scriptIdEl.value = scriptId;
      secretEl.value   = secret;
      deviceEl.value   = device;
      setBadge(Boolean(scriptId && secret));
    }

    // Preluare din URL + curățare parametri
    (function loadFromURL(){
      const params = new URLSearchParams(location.search);
      const sid = params.get('SCRIPT_ID') || params.get('scriptId') || params.get('sid') || params.get('SID') || '';
      const sec = params.get('SECRET')    || params.get('secret')   || params.get('token') || params.get('TOKEN') || '';
      let changed = false;
      if (sid) { localStorage.setItem('scanner_script_id', sid); changed = true; }
      if (sec) { localStorage.setItem('scanner_secret',   sec); changed = true; }
      if (changed) {
        ['SCRIPT_ID','scriptId','sid','SID','SECRET','secret','token','TOKEN'].forEach(k => params.delete(k));
        const newQs  = params.toString();
        const newUrl = location.pathname + (newQs ? '?' + newQs : '') + location.hash;
        history.replaceState(null, '', newUrl);
      }
    })();

    fillInputsFromStorage();
    document.getElementById('saveCfgBtn').addEventListener('click', () => { saveCfg({scriptId: scriptIdEl.value, secret: secretEl.value, device: deviceEl.value}); log('Config salvată local.', 'ok'); });
    document.getElementById('clearCfgBtn').addEventListener('click', clearCfg);

    // ============== Utilități UI & rețea ==============
    function log(msg, cls='') {
      const last = document.getElementById('last');
      last.innerHTML = `<div class="${cls}">${msg}</div>` + last.innerHTML;
    }
    const secureOk = () => (window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost');
    function buildWebhook() {
      const {scriptId} = getCfg();
      return scriptId ? (BASE_WEBAPP + scriptId + "/exec") : '';
    }

    // ============== Clasificare EAN & lookup titluri ==============
    function classifyPublication(ean13) {
      if (!/^\d{13}$/.test(ean13)) return { type:'other' };
      if (ean13.startsWith('977')) return { type:'issn' };                 // seriale
      if (ean13.startsWith('978') || ean13.startsWith('979')) return { type:'isbn' }; // cărți
      return { type:'other' };
    }

    function issnFromEan13(ean) {
      if (!/^\d{13}$/.test(ean) || !ean.startsWith('977')) return null;
      const issn7 = ean.substring(3, 10);
      const variant = ean.substring(10, 12);
      const weights = [8,7,6,5,4,3,2];
      let sum = 0; for (let i=0;i<7;i++) sum += (+issn7[i]) * weights[i];
      const r = sum % 11, cd = (11 - r) % 11, check = (cd === 10) ? 'X' : String(cd);
      return { issn: issn7.slice(0,4)+'-'+issn7.slice(4)+check, variantCode: variant };
    }

    const titleCache = new Map(); // mic cache în memorie

    async function lookupTitleByISSN(issn) {
      const key = 'issn:'+issn;
      if (titleCache.has(key)) return titleCache.get(key);
      try {
        const r = await fetch(`https://api.crossref.org/journals/${encodeURIComponent(issn)}`, { headers:{Accept:'application/json'} });
        if (!r.ok) throw 0; const j = await r.json();
        const t = j?.message?.title || j?.message?.publisher || '—';
        titleCache.set(key, t); return t;
      } catch { titleCache.set(key, '—'); return '—'; }
    }

    async function lookupTitleByISBN(isbn13) {
      const key = 'isbn:'+isbn13;
      if (titleCache.has(key)) return titleCache.get(key);
      try {
        const r = await fetch(`https://openlibrary.org/isbn/${isbn13}.json`, { headers:{Accept:'application/json'} });
        if (!r.ok) throw 0;
        const j = await r.json();
        const t = j?.title || '—';
        titleCache.set(key, t); return t;
      } catch { titleCache.set(key, '—'); return '—'; }
    }

    // ===== POST cu fallback anti-CORS =====
    async function postToSheet(payload) {
      const {secret, device} = getCfg();
      const webhook = buildWebhook();
      if (!webhook || !secret) return { ok:false, info:'Config incompletă (Script ID/Secret).' };

      // 1) JSON
      try {
        const r = await fetch(webhook, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ token: secret, deviceId: device || '', ...payload })
        });
        const j = await r.json().catch(()=> ({}));
        return { ok: !!j.ok, info: j.error || '' };
      } catch(e1) {
        // 2) x-www-form-urlencoded
        try {
          const form = new URLSearchParams();
          form.set('token', secret);
          form.set('deviceId', device || '');
          Object.entries(payload).forEach(([k,v]) => form.set(k, v ?? ''));
          const r2 = await fetch(webhook, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: form.toString()
          });
          const j2 = await r2.json().catch(()=> ({}));
          return { ok: !!j2.ok, info: j2.error || '' };
        } catch(e2) {
          return { ok:false, info: String(e2) };
        }
      }
    }

    // ============== Cameră + BarcodeDetector ==============
    const preview = document.getElementById('preview');
    const startBtn = document.getElementById('startBtn');
    const stopBtn  = document.getElementById('stopBtn');
    const torchBtn = document.getElementById('toggleTorchBtn');

    let stream = null, detector = null, scanning = false;
    let lastEan = null, lastAt = 0;

    async function ensureBarcodeDetector() {
      if (!('BarcodeDetector' in window)) return false;
      try {
        const formats = await window.BarcodeDetector.getSupportedFormats();
        return formats.includes('ean_13') || formats.includes('ean13');
      } catch { return false; }
    }
    async function startCamera() {
      if (!secureOk()) { log('Pagina nu este pe HTTPS — accesul la cameră va fi blocat.', 'err'); return; }
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: 'environment' } },
          audio: false
        });
        preview.srcObject = stream; await preview.play();
        stopBtn.disabled = false;
        try {
          const track = stream.getVideoTracks?.()[0];
          const caps = track?.getCapabilities?.();
          if (caps && 'torch' in caps) torchBtn.disabled = false;
        } catch {}
      } catch(e) {
        if (e.name === 'NotAllowedError' || e.name === 'SecurityError') log('Acces la cameră blocat de permisiuni.', 'err');
        else if (e.name === 'NotFoundError') log('Nu există cameră disponibilă sau e ocupată.', 'err');
        else log('Eroare pornire cameră: ' + (e.message || e.name), 'err');
      }
    }
    function stopCamera() {
      try { stream?.getTracks?.().forEach(t=>t.stop()); } catch {}
      stream = null; preview.srcObject = null;
      scanning = false; stopBtn.disabled = true; torchBtn.disabled = true;
    }
    async function toggleTorch() {
      const track = stream?.getVideoTracks?.()[0];
      if (!track) return;
      try {
        const caps = track.getCapabilities?.(); if (!caps || !('torch' in caps)) return log('Torch nesuportat pe acest device.', 'err');
        const st = track.getSettings?.()||{};
        await track.applyConstraints({ advanced:[{ torch: !st.torch }] });
      } catch (e) { log('Nu pot controla lanterna: ' + e.message, 'err'); }
    }

    async function scanLoop() {
      if (!detector || !scanning) return;
      try {
        const barcodes = await detector.detect(preview);
        if (barcodes && barcodes.length) {
          for (const b of barcodes) {
            const raw = String(b.rawValue || '').trim();
            if (!raw) continue;
            const now = Date.now();
            if (raw === lastEan && (now - lastAt) < 2000) continue;
            lastEan = raw; lastAt = now;

            const cls = classifyPublication(raw);
            if (cls.type === 'other') { log(`Detectat GTIN-13 non-publicație: ${raw} (ignorat)`, 'err'); continue; }

            let title = '—', issn = null, variantCode = null, isbn = null;
            if (cls.type === 'issn') {
              const p = issnFromEan13(raw);
              if (p) { issn = p.issn; variantCode = p.variantCode; title = await lookupTitleByISSN(issn); }
            } else if (cls.type === 'isbn') {
              isbn = raw;
              title = await lookupTitleByISBN(isbn);
            }

            const webhook = buildWebhook();
            const {secret} = getCfg();
            if (!webhook || !secret) {
              log(`EAN: ${raw}\nTip: ${cls.type.toUpperCase()}\nTitlu: ${title}\n(Configurează Script ID & Secret – vezi secțiunea Config sau setează din URL)`, 'err');
              continue;
            }

            const payload = {
              type: cls.type, ean: raw,
              issn: issn || '', isbn: isbn || '',
              title, variantCode: variantCode || ''
            };
            const resp = await postToSheet(payload);
            if (resp.ok) {
              log(`✔ Salvat [${cls.type.toUpperCase()}]\nEAN: ${raw}\n${issn?('ISSN: '+issn+'\n'):''}${isbn?('ISBN: '+isbn+'\n'):''}Titlu: ${title}${variantCode?('\nVariant: '+variantCode):''}`, 'ok');
            } else {
              log(`✖ Eroare la salvare: ${resp.info||'(unknown)'}\nEAN: ${raw}`, 'err');
            }
          }
        }
      } catch(e) {
        // erori izolate la detectare — ignorăm
      } finally {
        if (scanning) requestAnimationFrame(scanLoop);
      }
    }

    // Legare butoane
    startBtn.addEventListener('click', async () => {
      await startCamera();
      const supported = await ensureBarcodeDetector();
      if (!supported) { log('Browserul tău nu suportă BarcodeDetector (EAN-13). Încearcă Chrome/Edge pe Android sau iOS actualizat.', 'err'); return; }
      detector = new window.BarcodeDetector({ formats: ['ean_13'] });
      scanning = true; requestAnimationFrame(scanLoop);
      startBtn.disabled = true;
    });
    stopBtn.addEventListener('click', () => { scanning = false; stopCamera(); startBtn.disabled = false; });
    torchBtn.addEventListener('click', toggleTorch);

    if (!secureOk()) log('Atenție: deschide pagina pe HTTPS (GitHub Pages e HTTPS implicit).', 'err');
  </script>
</body>
</html>
